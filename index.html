<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Reproduceable software experiments through semantic configurations</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css">
  <link rel="stylesheet" media="print"  href="styles/print.css">
</head>
<body>
  <header>
  <h1 id="reproduceable-software-experiments-through-semanticconfigurations">Reproduceable software experiments through semantic configurations</h1>

  <ul id="authors">
    <li><a href="http://www.rubensworks.net/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://joachim-loves-hamburgersss.linkedsoftwaredependencies.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://csarven.ca/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://csarven.ca/#i">Sarven Capadisli</a>
<a href="#eisd"><sup>2</sup></a></li>
    <li><a href="https://ruben.verborgh.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>
<a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
    <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The scientific process requires reproducible experiments and findings
to foster trust and accountability.
Within computer science engineering,
reproducing experiments involves setting up
the exact same software with the same benchmarks and test data,
which often requires non-trivial manual work.
<!-- Need         -->
Unfortunately,
many research articles ambiguously refer to software by name only,
leaving out crucial details such as module and dependency version numbers
or the configuration of the individual components.
<!-- Task         -->
To this end, we created vocabularies
for the semantic description of software components and their configuration,
which can be published as Linked Data alongside experimental results.
We implemented a dependency injection framework
to accurately instantiate these described experimental configurations.
<!-- Object       -->
This article discusses the approach and its application,
and explains with a use case
how to publish experiments and their software configurations on the Web.
<!-- Findings     -->
In order to enable semantic interlinking between configurations and modules,
we published the metadata of all 475,000+ JavaScript libraries on npm
as 150,000,000+ RDF triples.
<!-- Conclusion   -->
Through our work,
research articles can refer by URL
to fine-grained, instantiatable descriptions of experimental setups,
completing the provenance chain from
specifications to implementations, dependencies, and configurations
all the way to experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.
<!-- Perspectives -->
Moreover, this work can serve other use cases,
such as general software instantiation outside of experiments,
and query execution over software configuration metadata.</p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>

    <p>Too many computer science articles
that contain experimental software evaluations
identify that software only by name and, sometimes, version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which exact versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has in fact obtained the reported results.
Therefore, potential users cannot necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any of these aspects.</p>

    <p>As <a property="http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a class="reference" href="#ref-1">[1]</a> explains,
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment, the involved artefacts and actors,
and the processing of the retrieved data.</p>

    <p>Using Linked Data to publish such descriptions provides two immediate benefits:
the experimental setup and parts thereof can be <em>identified with IRIs</em>,
and their details can be retrieved by <em>dereferencing those IRIs</em>.
Therefore, if research articles complement their textual explanation of an experiment
with the IRI of the full setup, reproducibility is guaranteed</p>

    <p class="todo">“Guaranteed” may be too strong?</p>
    <p>Moreover, the IRIs of the entire experiment or its parts
can be reused in other articles or experiment
to unambiguously refer to the same conditions.
<a href="#description-diagram">Fig. 1</a> illustrates how this leads to a chain of provenance
from the research article to the data
and the experiment that generates it,
and all the aspects surrounding that experiment.</p>

    <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
        <p><span class="label">Fig. 1:</span> A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article focuses on <em>software configurations</em> and <em>software modules</em>.</p>
      </figcaption>
</figure>

    <p>In this article,
we focus on the description of <em>software configurations</em> and <em>software modules</em>,
such that an evaluated software setup
can be referred to unambiguously by an IRI.
We thereby avoid the inherent vagueness
of referring to software by name only.
We further facilitate the reproduction of experiments
through a mechanisms that automatically <em>instantiates</em> the software configuration
based on its Linked Data description.
Our contributions are the following:</p>

    <ul>
      <li>the RDF-based description of <strong>software modules</strong>,
applied to the 475,000+ bundles of the npm ecosystem for Node.js;</li>
      <li>the RDF-based description of <strong>available components</strong> within software modules;</li>
      <li>the RDF-based description of a <strong>precise configuration</strong> of software modules;</li>
      <li>the <strong>automated instantiation</strong> of such a configuration;</li>
      <li>a <strong>use case</strong> explaining the usage of the resulting Linked Data
in scientific articles.</li>
    </ul>

    <p class="todo">Would a figure explaining the relation between module, component, configuration and instance be useful here?</p>

    <p>This article is structure as follows.
In <a href="#related-work">Section 2</a>, we will start by explaining the related work.
Next, in <a href="#overview">Section 3</a> we present an overview of the required steps for software experimentations that will be discussed in this paper.
<a href="#describing-modules">Section 4</a> introduces the semantic description of software modules.
Next, <a href="#describing-components">Section 5</a> discusses a semantic description of software components,
followed by the introduction of a dependency injection framework that can instantiate these described components in <a href="#instantiating">Section 6</a>.
In <a href="#use-case">Section 7</a>, we present a use case where we apply our proposed experiment workflow.
Finally, we discuss our conclusions and future work in <a href="#conclusion">Section 8</a></p>
  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p>In this section, we discuss the related work on the reproducibility of scientific experiments in scholarly articles,
ontologies for describing these experiments, and dependency injection as a design principle in experimental software.</p>

    <h3 id="scholarly-publishing-and-reproducibility">Scholarly publishing and reproducibility</h3>
    <p class="todo">Sarven will start this</p>

    <p class="todo">We should cite <a property="http://purl.org/spar/cito/cites" href="http://laurensrietveld.nl/pdf/lodlab.pdf">LOD Lab</a> <a class="reference" href="#ref-2">[2]</a>,
as they brought a major new angle to reproducibility within the Semantic Web.
Should also look at their argumentation.</p>

    <h3 id="ontologies-and-vocabularies-for-describing-experiments">Ontologies and vocabularies for describing experiments</h3>
    <p class="todo">Sarven will start this</p>

    <h3 id="related-work-dependency-injection">Dependency injection</h3>

    <p>Separation of concerns <a class="reference" href="#ref-3">[3]</a> is a software design principle in which software is
split up into separate components, each having their own separate task.
Fowler defines a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-4">[4]</a> as
<q>a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component</q>.
This design principle is especially useful for experimental software,
because it improves flexibility when for instance different implementations of an algorithm are be compared using different components.</p>

    <p>One way of working with components is to call their functions yourself, which means that your define the flow of control.
Alternatively, with <a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a> <a class="reference" href="#ref-5">[5]</a><a class="reference" href="#ref-6">[6]</a>,
this flow can be defined by a software framework.
In the latter case, the functions of the framework don’t have to be called by you, but the framework will call you for certain functionality when needed<sup id="fnref:HollywoodPrinciple"><a href="#fn:HollywoodPrinciple" class="footnote">1</a></sup>.</p>

    <p><a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> <a class="reference" href="#ref-4">[4]</a> is a form of Inversion of Control where components
are injected into other components by an external component, i.e., an <em>Assembler</em>.
Experimental software is a category of software that benefits from this paradigm,
because it allows different components to be defined and injected independently
into this software to observe its experimental effects.</p>

    <p>Three types of dependency injection are typically distinguished:</p>

    <ul>
      <li>Interface injection: The assembler calls an <code>inject</code> method in the target component to inject its dependencies.</li>
      <li>Setter injection: The assembler maps interfaces to implementation instances.</li>
      <li>Constructor injection: The assember maps interfaces to implementation classes with their constructor parameters and allows dynamic construction.</li>
    </ul>

    <p>Each of these types require a configuration phase to wire the component instances or factories,
and an injection phase to plug in the actual dependencies inside components.
This wiring can either be done in code, or through external configuration files.
These configuration files are typically declarative, and can be defined in formats such as XML or JSON.
Separating configuration from code is considered a good practise in software design,
as it follows the principle of separating interfaces from implementation.</p>

  </section>

  <section id="overview">
    <h2>Overview of software experiment descriptions</h2>

    <p class="todo">This section will shortly introduce each of the blocks in the diagram.
Ruben V. will write the basis.</p>

    <p class="todo">Mention somewhere here that we will use JSON-LD syntax for the examples in this paper.</p>

    <h4 id="specification">Specification</h4>
    <p class="todo">Write</p>

    <h4 id="module">Module</h4>
    <p class="todo">Write</p>

    <p class="todo">A module consists of <em>components</em></p>

    <h4 id="configuration">Configuration</h4>
    <p class="todo">Write</p>

    <h4 id="experiment">Experiment</h4>
    <p class="todo">Write</p>

    <h4 id="results">Results</h4>
    <p class="todo">Write</p>

    <h4 id="article">Article</h4>
    <p class="todo">Write</p>

  </section>

  <section id="describing-modules">
    <h2>Describing software modules</h2>

    <p class="todo">Joachim writes this</p>

    <p>There are several levels of granularity on which software can be described,
going from a high-level package overview to a low-level description of the actual code.
In our descriptions we make use of several of these layers,
depending on the context and the requirements.
Drilling down from the top to the bottom, we have the following layers:</p>

    <ul>
      <li>a <em>bundle</em> is a container. It describes what the software is expected to do. 
 An example of this would be the <em>N3.js</em> library.</li>
      <li>a <em>module</em> is a software package implementing a specific bundle. 
 This is also known as a version of a bundle.
 <em>N3.js 0.10.0</em> is a module.</li>
      <li>a <em>component</em> is a specific part of a module 
 that can be called in a certain way with a certain set of parameters.
 The <em>N3.js 0.10.0 Parser</em> is a component.</li>
    </ul>

    <p class="todo">I don’t like how this line sticks to the listing</p>

    <p>Within this section we will focus on bundles and modules,
while components are described more in-depth in the following sections.</p>

    <h3 id="node-package-manager-npm">Node Package Manager (npm)</h3>
    <p>An example of a large collection of bundles and modules is the npm library.
It contains over 475,000 Node.js libraries,
all with their own features and requirements.
Using our terminology,
an npm package would be a bundle,
while a specific version of such a package would be a module.
The package contains the description of the project together with all its versions,
while a version contains the specific dependencies and a link to the actual implementation.</p>

    <p>All this npm data is stored in a <a href="http://couchdb.apache.org/">CouchDB</a> 
<a href="https://registry.npmjs.org/">instance</a> with one entry per bundle.
This corresponds to the <a href="https://docs.npmjs.com/files/package.json">metadata</a> added by the package developer,
with additional metadata automatically added by the npm publishing process.
To be able to uniquely identify software components and,
more importantly, interlink software components,
we converted the JSON metadata provided by the npm registry to RDF.</p>

    <h3 id="json-ld">JSON-LD</h3>
    <p>Since our input data is JSON,
it made sense to convert to <a href="http://json-ld.org/">JSON-LD</a>,
a format specifically made for adding semantics to JSON.
JSON-LD achieves this by adding a so-called <em>context</em> to the JSON data.
This context describes how the JSON tags should be interpreted.
E.g., having <code>"name": "foaf:name"</code> in your context implies
that all name tags should be interpreted as the predicate <code>foaf:name</code>.
Other JSON-LD keywords can be used to identify if certain values are URIs,
or if an entity has a specific type.
For the data where we could not reach the format using just the JSON-LD context,
such as concatenating values to create a URI,
we modified some of the input JSON before exporting it to JSON-LD.</p>

    <p class="todo">Decrease tags in examples for pages.
Probably also drop either JSON-LD or turtle</p>

    <h3 id="bundles">Bundles</h3>
    <p>A bundle represents the general npm package.
<a href="#n3.json">Listing 1</a> shows a subset of what metadata can be found in the npm repository.
Since this is a bundle this contains general descriptions,
such as the name and homepage.
<a href="#n3.jsonld">Listing 2</a> then shows the JSON-LD version of this same metadata.
As can be seen, some tags were added to provide additional information,
e.g., a link to the actual npm repository,
but most of the tags stayed the same,
getting their metadata information from the context.
One of important changes that we made is minting URIs for the specific versions of a package,
as can be seen with the versions tag,
and providing that information when the URI for the specific version gets accessed.
In <a href="#n3.ttl">Listing 3</a> a turtle representation of the same data is shown.
These RDF examples can also be found by accessing 
<a href="https://linkedsoftwaredependencies.org/bundles/npm/n3">https://linkedsoftwaredependencies.org/bundles/npm/n3</a>
with the corresponding <em>Accept</em> headers.</p>

    <figure id="n3.json" class="listing">
<pre><code>{
    &quot;name&quot;: &quot;n3&quot;,
    &quot;description&quot;: &quot;Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.&quot;,
    &quot;author&quot;: {
        &quot;name&quot;: &quot;Ruben Verborgh&quot;,
        &quot;email&quot;: &quot;ruben.verborgh@gmail.com&quot;
    },
    &quot;versions&quot;: { &quot;0.10.0&quot;: { &quot;name&quot;: &quot;n3&quot;, &quot;version&quot;: &quot;0.0.1&quot; } }
    &quot;homepage&quot;: &quot;https://github.com/RubenVerborgh/N3.js#readme&quot;,
    &quot;keywords&quot;: [ &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot; ],
    &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/RubenVerborgh/N3.js/issues&quot; },
    &quot;license&quot;: &quot;MIT&quot;
}
</code></pre>
<figcaption>
        <p><span class="label">Listing 1:</span> Subset of the JSON npm representation of the N3 package.</p>
      </figcaption>
</figure>

    <figure id="n3.jsonld" class="listing">
<pre><code>{
    &quot;@context&quot;: &quot;https://linkedsoftwaredependencies.org/contexts/npm&quot;,
    &quot;name&quot;: &quot;n3&quot;,
    &quot;description&quot;: &quot;Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.&quot;,
    &quot;author&quot;: {
        &quot;@id&quot;: &quot;http://linkedsoftwaredependencies.org/users/npm/rubenverborgh&quot;,
        &quot;foaf:name&quot;: &quot;Ruben Verborgh&quot;,
        &quot;email&quot;: &quot;ruben.verborgh@gmail.com&quot;
    },
    &quot;versions&quot;: { &quot;0.10.0&quot;: &quot;http://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&quot; },
    &quot;homepage&quot;: &quot;https://github.com/RubenVerborgh/N3.js#readme&quot;,
    &quot;keywords&quot;: [ &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot; ],
    &quot;bugs&quot;: { &quot;url&quot;: &quot;https://github.com/RubenVerborgh/N3.js/issues&quot; },
    &quot;license&quot;: {
        &quot;@id&quot;: &quot;https://spdx.org/licenses/MIT.html&quot;,
        &quot;spdx:name&quot;: &quot;MIT&quot;
    },
    &quot;@id&quot;: &quot;https://linkedsoftwaredependencies.org/bundles/npm/n3&quot;,
    &quot;owl:sameAs&quot;: &quot;https://www.npmjs.com/package/n3&quot;,
    &quot;@type&quot;: &quot;doap:Project&quot;
}</code></pre>
<figcaption>
        <p><span class="label">Listing 2:</span> JSON-LD representation of <a href="#n3.json">Listing 1</a>.</p>
      </figcaption>
</figure>

    <figure id="n3.ttl" class="listing">
<pre><code>npm:n3 a doap:Project;
    dcterms:abstract &quot;Lightning fast, asynchronous, streaming Turtle / N3 / RDF library.&quot;;
    dcterms:subject &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot;;
    spdx:licenseDeclared &lt;https://spdx.org/licenses/MIT.html&gt;;
    doap:release &lt;http://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&gt;;
    doap:bug-database &lt;https://github.com/RubenVerborgh/N3.js/issues&gt;;
    doap:homepage &lt;https://github.com/RubenVerborgh/N3.js#readme&gt;;
    doap:name &quot;n3&quot;;
    owl:sameAs &quot;https://www.npmjs.com/package/n3&quot;;
    foaf:maker users:rubenverborgh.
users:rubenverborgh foaf:mbox &quot;ruben.verborgh@gmail.com&quot;;
    foaf:name &quot;Ruben Verborgh&quot;.
</code></pre>
<figcaption>
        <p><span class="label">Listing 3:</span> Turtle representation of <a href="#n3.ttl">Listing 3</a>.
Prefix definitions omitted for brevity.</p>
      </figcaption>
</figure>

    <h3 id="modules">Modules</h3>
    <p>A module is a specific version of a package.
Continuing with the examples shown above,
<a href="#n3-0.10.0.json">Listing 4</a> provides some tags present
in the npm metadata of N3 version 0.10.0.
Since the general case of tags has already been covered above,
we focus on several more interesting tags in the metadata shown here.</p>

    <p>As can be seen in the JSON-LD version in <a href="#n3-0.10.0.jsonld">Listing 5</a>,
we minted several new URIs here.
In the dependencies, we now link to the semantic version <code>^2.0.1</code> 
of the async package in our own namespace.
This version corresponds to any version number of that package
that does not modify the left-most non-zero digit of the given version.
When accessing this URI,
the semantic version number will be interpreted
and a redirect will be given to the highest matching actual number.
In this case, a redirect will be given to 
<a href="https://linkedsoftwaredependencies.org/bundles/npm/async/2.4.0">https://linkedsoftwaredependencies.org/bundles/npm/async/2.4.0</a>.</p>

    <p>For the scripts we also generated new URIs.
Several scripts are predefined by npm,
meaning they get shared by many packages,
so a shared URI for those makes sense.
The actual content of the script can be accessed by accessing the new script URI,
allowing for easier automation by services that can execute these scripts.</p>

    <figure id="n3-0.10.0.json" class="listing">
<pre><code>{
    &quot;version&quot;: &quot;0.10.0&quot;,
    &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;=0.10.0&quot; },
    &quot;devDependencies&quot;: { &quot;async&quot;: &quot;^2.0.1&quot; },
    &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha&quot; }
}</code></pre>
<figcaption>
        <p><span class="label">Listing 4:</span> Subset of the JSON npm representation N3 version 0.10.0.</p>
      </figcaption>
</figure>

    <figure id="n3-0.10.0.jsonld" class="listing">
<pre><code>{
    &quot;@context&quot;: [
        &quot;https://linkedsoftwaredependencies.org/contexts/npm&quot;,
        { &quot;script&quot;: &quot;https://linkedsoftwaredependencies.org/scripts/npm/&quot;}
    ],
    &quot;version&quot;: &quot;0.10.0&quot;,
    &quot;engines&quot;: { &quot;node&quot;: &quot;https://linkedsoftwaredependencies.org/engines/node/%3E%3D0.10.0&quot; },
    &quot;devDependencies&quot;: { &quot;async&quot;: &quot;https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1&quot; },
    &quot;scripts&quot;: { &quot;script:test&quot;: &quot;https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0/scripts/test&quot; }
}</code></pre>
<figcaption>
        <p><span class="label">Listing 5:</span> Subset of the JSON npm representation N3 version 0.10.0.</p>
      </figcaption>
</figure>

  </section>

  <section id="describing-components">
    <h2>Describing components and their configuration</h2>

    <p>In this section, we introduce a vocabulary for describing software components and how they can be instantiated.
We provide an example of the application of this vocabulary to object-oriented software components using JavaScript.</p>

    <h3 id="object-oriented-components">Object-oriented components</h3>

    <p>Within the <a href="http://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>object-oriented components vocabulary</em></a>,
we reuse Fowler’s definition of a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-4">[4]</a> as a “glob” of software.
The purpose of a component is to provide operations that can be used by other components.
The instantiation of a component can require certain parameters,
just like object-oriented programming (OOP) languages allow constructors to have certain arguments.
In this section, we assume OOP in the broad sense of the word, which only requires <em>classes</em>, <em>objects</em> and <em>constructor parameters</em>.
<a href="#voc-oo-diagram">Fig. 2</a> shows an overview of all the classes and predicates in the components vocabulary.</p>

    <figure id="voc-oo-diagram">
<img src="voc-oo-diagram.svg" alt="[Object-oriented components vocabulary diagram]" />
<figcaption>
        <p><span class="label">Fig. 2:</span> Overview of the classes and properties in the <em>object-oriented components</em> vocabulary.</p>
      </figcaption>
</figure>

    <p>We define a <em>module</em> as a collection of components.
Within OOP languages, this can correspond to for example a software library or an application,
which can contain a multitude of functionalities, i.e., components.</p>

    <p>We define component as a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct a component can therefore be defined as an <code>rdfs:Property</code> on a component.
This class structure enables convenient semantic descriptions of components instantiations,
requiring only the fundamental concepts of RDF classes and properties.</p>

    <p>Several <code>oo:Component</code> subclasses are defined.
An <code>oo:Component</code> can be an <code>oo:Class</code>, which means that it can be instantiated based on parameters.
All instantiations of <code>oo:Class</code> instances are an <code>oo:Instance</code>.
It can also be an <code>oo:Instance</code>, meaning that it can directly be used within other components and needs no further instantiation.
An <code>oo:Class</code> can also be <code>oo:AbstractClass</code>, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicated using the <code>rdfs:subClassOf</code> predicate.</p>

    <p>The parameters that are used to instantiate an <code>oo:Class</code> to an <code>oo:Instance</code> are of type <code>oo:Parameter</code>.
An <code>oo:Parameter</code> is a <em>subclass</em> of <code>rdfs:Property</code>, which simplifies its usage as an RDF property.
<code>oo:defaultValue</code> allows parameters to have a default value when no other values have been provided.
The <code>oo:uniqueValue</code> predicate is a flag that can be set to indicate whether or not the parameter can only have a single value.</p>

    <p><a href="#module-n3">Listing 6</a> shows an example of the N3.js npm module using the components vocabulary.
It exposes several components such as <em>Parser</em> and <em>Lexer</em>.
Each of these components can take several different parameters.
<a href="#config-n3">Listing 7</a> illustrates how instances can be created of these component types.</p>

    <figure id="module-n3" class="listing">
<pre><code>ex:n3 a oo:Module;
    oo:hasComponents
        n3:Parser,
        n3:Lexer.

n3:Parser a oo:Class
    oo:hasParameter n3:format,
        n3:blankNodePrefix,
        n3:lexer,
        n3:explicitQuantifiers.

n3:format a oo:Parameter;
    rdfs:range xsd:string.
n3:blankNodePrefix a oo:Parameter;
    rdfs:range xsd:string.
n3:lexer a oo:Parameter;
    rdfs:range n3:Lexer.
n3:explicitQuantifiers a oo:Parameter;
    rdfs:range xsd:boolean.

n3:Lexer a oo:Class
    oo:hasParameter n3:lineMode,
        n3:n3,
        n3:comments;

n3:lineMode a oo:Parameter;
    rdfs:range xsd:boolean.
n3:n3 a oo:Parameter;
    rdfs:range xsd:boolean.
n3:comments a oo:Parameter;
    rdfs:range xsd:boolean.</code></pre>
<figcaption>
        <p><span class="label">Listing 6:</span> The N3.js module contains a parser, lexer and util component.
The parser and lexer are a constructable components.
The parser has a parameter that takes another component, a lexer, as input.
The util component already is an instance, for which it needs no parameters.</p>
      </figcaption>
</figure>

    <figure id="config-n3" class="listing">
<pre><code>ex:myLexer a n3:Lexer;
    n3:comments &quot;true&quot;^^xsd:boolean.

ex:myParser a n3:Parser;
    n3:format &quot;application/trig&quot;;
    n3:lexer ex:myLexer.</code></pre>
<figcaption>
        <p><span class="label">Listing 7:</span> <code>ex:myLexer</code> is a lexer that accepts comments.
<code>ex:myParser</code> is a parser that accepts the TriG format and uses <code>ex:myLexer</code> for lexing.</p>
      </figcaption>
</figure>

    <p>{:.todo} mention reasoning for checking things like valid parameter range</p>

    <h3 id="object-mapping">Object mapping</h3>

    <p>A consequence of using RDF to instantiate components is that the parameters have no fixed order.
While this is sufficient to describe component instantiations on a semantic level,
it is insufficient for mapping parameter values to arguments in method and constructor calls that are based on a fixed ordering for parameters,
which is the case for most popular OOP languages.</p>

    <p>We introduce a new vocabulary for describing the mapping between the pure semantic parameters
to arguments in method calls in OOP languages like JavaScript, hence the name <a href="http://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>object mapping vocabulary</em></a>.
<a href="#voc-om-diagram">Fig. 3</a> shows an overview of all the classes and predicates in the components vocabulary.</p>

    <figure id="voc-om-diagram">
<img src="voc-om-diagram.svg" alt="[Object mapping vocabulary diagram]" />
<figcaption>
        <p><span class="label">Fig. 3:</span> Overview of the classes and properties in the <em>object mapping</em> vocabulary.</p>
      </figcaption>
</figure>

    <p>Our vocabulary introduces the <em>object map</em> and the <em>array map</em>, the latter is a subclass of the former.
An object map can have several <em>object map entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array map entries</em>, each entry only has a value.</p>

    <p>If the value of <code>om:fieldName</code> or <code>om:fieldValue</code> is a literal, the literal value will be mapped to the object field name or value.
An <code>om:fieldValue</code> can also refer to another object map, which will be mapped to the resulting object.
<code>om:collectsEntriesFrom</code> can refer to a predicate that points to entities with certain predicates.
Each entity predicate that is refered to by <code>om:fieldName</code> will have its values mapped to keys of the object.
Each entity predicate refered to by <code>om:fieldValue</code> will have its values mapped to values.
<a href="#om-collects-module">Listing 8</a>, <a href="#om-collects-data">Listing 9</a> and <a href="#om-collects-result">Listing 10</a> show an example of this entry collection process.</p>
    <figure id="om-collects-module" class="listing">
<pre><code>:myOm om:hasField [
    om:fieldName foaf:name;
    om:fieldValue: foaf:mbox.
    om:collectsEntriesFrom foaf:knows.
].</code></pre>
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 8:</span> An object mapping for mapping all <code>foaf:knows</code> resources to an object
with as key the <code>foaf:name</code> and as value the <code>foaf:mbox</code>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-data" class="listing">
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<figcaption>
        <p><span class="label">Listing 9:</span> All the people <code>:me</code> knows using the <a href="http://xmlns.com/foaf/spec/">FOAF vocabulary</a>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-result" class="listing">
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 10:</span> The resulting object when mapping the people <code>:me</code> knows from <a href="#om-collects-data">Listing 9</a>
using the object mapping from <a href="#om-collects-module">Listing 8</a>.</p>
      </figcaption>
</figure>

    <p><a href="#module-n3-mapped">Listing 11</a> shows the mapping of the N3.js component parameters to the constructor implementations.
This description enchances the component definitions from <a href="#module-n3">Listing 6</a>
as it provides a lower level (implementation) view on the component constructors.</p>

    <figure id="module-n3-mapped" class="listing">
<pre><code>n3:Parser oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;format&quot;;
        om:fieldValue: n3:format.
    ],
    [
        om:fieldName &quot;blankNodePrefix&quot;;
        om:fieldValue: n3:blankNodePrefix.
    ],
    [
        om:fieldName &quot;lexer&quot;;
        om:fieldValue: n3:lexer.
    ],
    [
        om:fieldName &quot;explicitQuantifiers&quot;;
        om:fieldValue: n3:explicitQuantifiers.
    ].
]).

n3:Lexer oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;lineMode&quot;;
        om:fieldValue: n3:lineMode.
    ],
    [
        om:fieldName &quot;n3&quot;;
        om:fieldValue: n3:n3.
    ],
    [
        om:fieldName &quot;comments&quot;;
        om:fieldValue: n3:comments.
    ].
]).</code></pre>
<figcaption>
        <p><span class="label">Listing 11:</span> Both the parameters of the parser and lexer component are respectively mapped to an object.
These objects are the single arguments of respectively the parser and lexer constructor.
The field value in this case is always a parameter.</p>
      </figcaption>
</figure>

  </section>

  <section id="instantiating">
    <h2>Instantiating component configurations</h2>

    <p class="todo">mention closing of the world</p>

    <p>In the previous section, we introduced a vocabulary for describing software components and how they can be instantiated.
In this section, we introduce a dependency injection framework based on these component descriptions.
With this, we take semantic software component descriptions to the next level,
we don’t only <em>describe</em> components, but also allow them to be <em>instantiated</em>.</p>

    <p>We have implemented, <a href="https://github.com/LinkedSoftwareDependencies/Components.js">Components.js</a>,
an open-source dependency injection framework for JavaScript, and made it available on <a href="https://www.npmjs.com/package/lsd-components">npm</a>.
It is able to construct component instances based on declarative component constructions in RDF using the vocabulary introduced in <a href="#describing-components">Section 5</a>.
It accepts raw triple streams or URL’s to RDF documents containing these declarations.
At the time of writing, the parser accepts RDF documents serialized in either JSON-LD, Turtle, TriG, N-Triples or N-Quads.</p>

    <p><a href="#components.js">Listing 12</a> illustrates how components can be instantiated using Components.js.
It provides a <code>Loader</code> class that acts as an assembler when instantiated.
This <code>Loader</code> is based on the principles of <em>Constructor injection</em>, as explained in <a href="#related-work-dependency-injection">Subsection 2.3</a>
It dynamically calls the constructor of the component and passes the configured parameters in a single object argument.
If a constructor mapping is detected, the parameter values will be mapped to constructor arguments as configured by the mapping.
Additionally, <a href="https://github.com/LinkedSoftwareDependencies/Components.js#component-configuration-unnamed">simplified mechanisms</a>
are in place for developers that want to use the dependency injector directly without having to semantically describe the component.</p>

    <figure id="components.js" class="listing">
<pre><code>const Loader = require(&#39;lsd-components&#39;).Loader;
let loader = new Loader();
loader.registerModuleResourcesUrl(
    &#39;http://example.org/module-n3.ttl&#39;)
    .then(() =&gt;loader.instantiateFromUrl(
        &#39;http://example.org/config-n3.ttl#myParser&#39;,
        &#39;http://example.org/config-n3.ttl&#39;))
    .then((parser) =&gt; { ... });</code></pre>
<figcaption>
        <p><span class="label">Listing 12:</span> First, a new component loader is created
after which module and component definitions are registered.
Finally, a declarative component instantiation is supplied by providing the component URI
and the location at which the resource can be found.</p>
      </figcaption>
</figure>

  </section>

  <section id="use-case">
    <h2>Use case: a Linked Data Fragments experiment</h2>

    <p class="todo">Sarven, Joachim, Ruben V. write this</p>

    <p><a property="http://purl.org/spar/cito/citesAsAuthority" href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments</a> <a class="reference" href="#ref-8">[8]</a></p>

    <p>We have implemented a new version of the <a href="https://github.com/LinkedDataFragments/Server.js/tree/feature-lsd">LDF server</a>
where all components are dynamically wired by Components.js.
We semantically describe the LDF server module and its 32 components, which results in x triples.
The configuration file used to be a <a href="https://github.com/LinkedDataFragments/Server.js/blob/master/config/config-example.json">JSON file</a>
with a custom domain-specific language.
Now, this configuration file is a declarative components file that can be understood by Components.js,
as can be seen in <a href="#ldf-server-config">Listing 13</a>.
This new configuration format has two major advantages:</p>

    <ul>
      <li>The configuration file is RDF data with a semantic meaning.</li>
      <li>External components can be injected by including declaratively into the config file.</li>
    </ul>

    <figure id="ldf-server-config" class="listing">
<pre><code>{
  &quot;@context&quot;: &quot;http://linkedsoftwaredependencies.org/contexts/ldf-server.jsonld&quot;,
  &quot;@id&quot;: &quot;urn:ldfserver:my&quot;,
  &quot;@type&quot;: &quot;QpfServer&quot;,

  &quot;title&quot;: &quot;My Linked Data Fragments server&quot;,

  &quot;datasources&quot;: [
    {
      &quot;@id&quot;: &quot;ldfs:defaultIndexDatasource&quot;
    },
    {
      &quot;@id&quot;: &quot;ex:myHdtDatasource&quot;,
      &quot;@type&quot;: &quot;HdtDatasource&quot;,
      &quot;datasourceTitle&quot;: &quot;DBpedia 2014&quot;,
      &quot;datasourceDescription&quot;: &quot;DBpedia 2014 with an HDT back-end&quot;,
      &quot;path&quot;: &quot;dbpedia&quot;,
      &quot;hdtFile&quot;: &quot;data/dbpedia2014.hdt&quot;
    },
    {
      &quot;@id&quot;: &quot;ex:mySparqlDatasource&quot;,
      &quot;@type&quot;: &quot;SparqlDatasource&quot;,
      &quot;datasourceTitle&quot;: &quot;DBpedia 3.9 (Virtuoso)&quot;,
      &quot;datasourceDescription&quot;: &quot;DBpedia 3.9 with a Virtuoso back-end&quot;,
      &quot;path&quot;: &quot;dbpedia-sparql&quot;,
      &quot;sparqlEndpoint&quot;: &quot;http://dbpedia.restdesc.org/&quot;,
      &quot;sparqlDefaultGraph&quot;: &quot;http://dbpedia.org&quot;
    }
  ]
}
</code></pre>
<figcaption>
        <p><span class="label">Listing 13:</span> We define an LDF server component of type <code>ldfs:Server/Qpf</code> in JSON-LD.
The two datasources are also components that are loaded into the LDF server.</p>
      </figcaption>
</figure>

    <p>{:.todo} count triples</p>

  </section>

  <section id="conclusion">
    <h2>Conclusion</h2>

    <p class="todo">Write</p>

    <p class="todo">Mention autogeneration of component files in future work</p>

  </section>

</main>

<footer>
      <section id="footnotes">
        <h2>Footnotes</h2>
        <ol>
    <li id="fn:HollywoodPrinciple">
      <p>This concept is also know as the Hollywood Principle <a class="reference" href="#ref-7">[7]</a>: <q>Don’t call us, we’ll call you</q>&nbsp;<a href="#fnref:HollywoodPrinciple" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
      </section>
    <section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd>Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd>Rietveld, L., Beek, W., Schlobach, S.: LOD Lab: Experiments at LOD Scale. In: Arenas, M., Corcho, O., Simperl, E., Strohmaier, M., d’Aquin, M., Srinivas, K., Groth, P., Dumontier, M., Heflin, J., Thirunarayan, K., and Staab, S. (eds.) Proceedings of the 14th International Semantic Web Conference. pp. 339–355. Springer (2015).</dd>
  <dt id="ref-3">[3]</dt>
  <dd>Hürsch, W.L., Lopes, C.V.: Separation of concerns. (1995).</dd>
  <dt id="ref-4">[4]</dt>
  <dd>Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern, <a href="https://martinfowler.com/articles/injection.html,">https://martinfowler.com/articles/injection.html,</a> (2004).</dd>
  <dt id="ref-5">[5]</dt>
  <dd>Fowler, M.: InversionOfControl, <a href="https://martinfowler.com/bliki/InversionOfControl.html,">https://martinfowler.com/bliki/InversionOfControl.html,</a> (2005).</dd>
  <dt id="ref-6">[6]</dt>
  <dd>Johnson, R.E., Foote, B.: Designing reusable classes. Journal of object-oriented programming. 1, 22–35 (1988).</dd>
  <dt id="ref-7">[7]</dt>
  <dd>Sweet, R.E.: The Mesa programming environment. In: ACM SIGPLAN Notices. pp. 216–229. ACM (1985).</dd>
  <dt id="ref-8">[8]</dt>
  <dd>Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, 184–206 (2016).</dd>
</dl>
</section>
</footer>





</body>
</html>
