<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Reproduceable software experiments through semantic configurations</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css">
  <link rel="stylesheet" media="print"  href="styles/print.css">
</head>
<body>
  <header>
  <h1 id="reproduceable-software-experiments-through-semanticconfigurations">Reproduceable software experiments through semantic configurations</h1>

  <ul id="authors">
    <li><a href="http://www.rubensworks.net/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://joachim-loves-hamburgersss.linkedsoftwaredependencies.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://csarven.ca/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://csarven.ca/#i">Sarven Capadisli</a>
<a href="#eisd"><sup>2</sup></a></li>
    <li><a href="https://ruben.verborgh.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>
<a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
    <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The scientific process requires reproducible experiments and findings
to foster trust and accountability.
Within computer science engineering,
reproducing experiments involves setting up
the exact same software with the same benchmarks and test data,
which often requires non-trivial manual work.
<!-- Need         -->
Unfortunately,
many research articles ambiguously refer to software by name only,
leaving out crucial details such as module and dependency version numbers
or the configuration of the individual components.
<!-- Task         -->
To this end, we created vocabularies
for the semantic description of software components and their configuration,
which can be published as Linked Data alongside experimental results.
We implemented a dependency injection framework
to accurately instantiate these described experimental configurations.
<!-- Object       -->
This article discusses the approach and its application,
and explains with a use case
how to publish experiments and their software configurations on the Web.
<!-- Findings     -->
In order to enable semantic interlinking between configurations and modules,
we published the metadata of all 475,000+ JavaScript libraries on npm
as 150,000,000+ RDF triples.
<!-- Conclusion   -->
Through our work,
research articles can refer by URL
to fine-grained, instantiatable descriptions of experimental setups,
completing the provenance chain from
specifications to implementations, dependencies, and configurations
all the way to experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.
<!-- Perspectives -->
Moreover, this work can serve other use cases,
such as general software instantiation outside of experiments,
and reasoning or querying over software configuration metadata.</p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>

    <p>A large number of computer science articles describe experimental software evaluations,
but many of them refer to that software only by name or version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which exact versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has obtained the reported results.
Therefore, potential users cannot necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any such aspects.</p>

    <p>As <a property="http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a class="reference" href="#ref-1">[1]</a> explains,
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment,
all of the involved artefacts and actors,
and the processing of the retrieved data.</p>

    <p>Using <a property="http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data</a> <a class="reference" href="#ref-2">[2]</a>
to publish such descriptions provides two immediate benefits:
the experimental setup and parts thereof can be <em>identified by IRIs</em>,
and their details can be retrieved by <em>dereferencing those IRIs</em>.
Therefore, if research articles complement their textual explanation of an experiment
with the IRI of the full setup, reproducibility is strongly facilitated.
Moreover, the IRIs of the entire experiment or its parts
can be reused in other articles or experiments
to unambiguously refer to the same conditions.
<a href="#description-diagram">Fig. 1</a> illustrates how this leads to a chain of provenance
from the research article to the data
and the experiment that generates it,
as well as all aspects surrounding that experiment.</p>

    <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
        <p><span class="label">Fig. 1:</span> A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article focuses on <em>software configurations</em> and <em>software modules</em>.</p>
      </figcaption>
</figure>

    <p>In this article,
we focus on the description of <em>software configurations</em> and <em>software modules</em>,
such that an evaluated software setup
can be referred to unambiguously by an IRI.
We thereby avoid the inherent vagueness
of referring to software by name or version only.
We further facilitate the reproduction of experiments
through a mechanisms that automatically <em>instantiates</em> the software configuration
based on its Linked Data description.
Our contributions are the following:</p>

    <ul>
      <li>the RDF-based description of <strong>software modules</strong>,
applied to the 475,000+ bundles of <a href="https://www.npmjs.com/">npm</a> (Node.js);</li>
      <li>the RDF-based description of <strong>available components</strong> within software modules;</li>
      <li>the RDF-based description of a <strong>precise configuration</strong> of software modules;</li>
      <li>the <strong>automated instantiation</strong> of such a configuration;</li>
      <li>a <strong>use case</strong> explaining the usage of the resulting Linked Data
in scientific articles.</li>
    </ul>

    <p>This article is structured as follows.
In <a href="#related-work">Section 2</a>, we discuss related work.
Next, in <a href="#overview">Section 3</a> we present an overview of the required steps for software experimentations that will be discussed in this paper.
<a href="#describing-modules">Section 4</a> introduces the semantic description of software modules.
Next, <a href="#describing-components">Section 5</a> discusses a semantic description of software components,
followed by the introduction of a dependency injection framework that can instantiate these described components in <a href="#instantiating">Section 6</a>.
In <a href="#use-case">Section 7</a>, we present a use case where we apply software descriptions
to an experimental evaluation.
Finally, we discuss our conclusions and future work in <a href="#conclusion">Section 8</a>.</p>

  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p>In this section, we discuss the related work on the reproducibility of scientific experiments in scholarly articles,
ontologies for describing these experiments, and dependency injection as a design principle in experimental software.</p>

    <h3 id="scholarly-publishing-and-reproducibility">Scholarly publishing and reproducibility</h3>
    <p>In order to better keep track of experiments and minimise information loss at CERN, <a property="http://purl.org/spar/cito/citesForInformation" href="https://www.w3.org/History/1989/proposal.html">Information Management: A Proposal</a> <a class="reference" href="#ref-3">[3]</a>, recommends a system (WWW) to address questions like <q>Where is this module used? Who wrote this code? Which systems depend on this device?</q>. We contend that the vision to link information systems in the domain of scientific experiments and scholarly articles is not fully realised on the Web. Identifiable parts of experiments, workflows, as well as the articles which refer to them, still predominantly require human intervention and interpretation, and thereby leaving deterministic reproducibility an open problem on the Web. Our work focuses on improving the state of <q>black box</q> science in particular to experiments using software from the <cite>node package manager</cite>.</p>

    <p class="todo">We should cite <a property="http://purl.org/spar/cito/cites" href="http://laurensrietveld.nl/pdf/lodlab.pdf">LOD Lab</a> <a class="reference" href="#ref-4">[4]</a>,
as they brought a major new angle to reproducibility within the Semantic Web.
Should also look at their argumentation.</p>

    <h3 id="ontologies-and-vocabularies-for-describing-experiments">Ontologies and vocabularies for describing experiments</h3>
    <p><a property="http://purl.org/spar/cito/cites" href="http://doi.acm.org/10.1145/2814864.2814882">LODFlow</a> <a class="reference" href="#ref-5">[5]</a> proposes the <cite><a href="https://github.com/AKSW/ldwpo">Linked Data Workflow Project Ontology</a></cite> to describe and plan workflows, tool configurations, and reporting.
Tool specifications and their configurations in LODFlow workflows are described declaratively by a human user without a prescribed schema.
Such descriptions are however interpretive in that any given tool is subject to having multiple descriptions by different users.
In contrast to the human-driven descriptions, our work both enables and accelerates the generation of machine-driven Linked Data descriptions of software modules, their components, as well as their configurations to be uniformly created.
Consequently, this makes it possible to accurately describe and instantiate software experiments that can be reused and compared with unambiguously.</p>

    <h3 id="related-work-dependency-injection">Dependency injection</h3>

    <p>Separation of concerns <a class="reference" href="#ref-6">[6]</a> is a software design principle in which software is
split up into separate components, each having their own separate task.
Fowler defines a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-7">[7]</a> as
<q>a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component</q>.
This design principle is especially useful for experimental software,
because it improves flexibility when for instance different implementations of an algorithm are be compared using different components.</p>

    <p>One way of working with components is to call their functions yourself, which means that your define the flow of control.
Alternatively, with <a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a> <a class="reference" href="#ref-8">[8]</a><a class="reference" href="#ref-9">[9]</a>,
this flow can be defined by a software framework.
In the latter case, the functions of the framework don’t have to be called by you, but the framework will call you for certain functionality when needed<sup id="fnref:HollywoodPrinciple"><a href="#fn:HollywoodPrinciple" class="footnote">1</a></sup>.</p>

    <p><a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> <a class="reference" href="#ref-7">[7]</a> is a form of Inversion of Control where components
are injected into other components by an external component, i.e., an <em>Assembler</em>.
Experimental software is a category of software that benefits from this paradigm,
because it allows different components to be defined and injected independently
into this software to observe its experimental effects.</p>

    <p>Three types of dependency injection are typically distinguished:</p>

    <ul>
      <li>Interface injection: The assembler calls an <code>inject</code> method in the target component to inject its dependencies.</li>
      <li>Setter injection: The assembler maps interfaces to implementation instances.</li>
      <li>Constructor injection: The assember maps interfaces to implementation classes with their constructor parameters and allows dynamic construction.</li>
    </ul>

    <p>Each of these types require a configuration phase to wire the component instances or factories,
and an injection phase to plug in the actual dependencies inside components.
This wiring can either be done in code, or through external configuration files.
These configuration files are typically declarative, and can be defined in formats such as XML or JSON.
Separating configuration from code is considered a good practise in software design,
as it follows the principle of separating interfaces from implementation.</p>

  </section>

  <section id="overview">
    <h2>Overview of software experiment descriptions</h2>

    <p class="todo">This section will shortly introduce each of the blocks in the diagram.
Ruben V. will write the basis.</p>

    <p class="todo">Mention somewhere here that we will use JSON-LD syntax for the examples in this paper.</p>

    <h4 id="specification">Specification</h4>
    <p class="todo">Write</p>

    <h4 id="module">Module</h4>
    <p class="todo">Write</p>

    <p class="todo">A module consists of <em>components</em></p>

    <h4 id="configuration">Configuration</h4>
    <p class="todo">Write</p>

    <h4 id="experiment">Experiment</h4>
    <p class="todo">Write</p>

    <h4 id="results">Results</h4>
    <p class="todo">Write</p>

    <h4 id="article">Article</h4>
    <p class="todo">Write</p>

  </section>

  <section id="describing-modules">
    <h2>Describing software modules</h2>

    <p class="todo">Joachim writes this</p>

    <p>There are several levels of granularity on which software can be described,
going from a high-level package overview to a low-level description of the actual code.
In our descriptions we make use of several of these layers,
depending on the context and the requirements.
Drilling down from the top to the bottom, we have the following layers:</p>

    <ul>
      <li>a <em>bundle</em> is a container. It describes what the software is expected to do. 
 An example of this would be the <em>N3.js</em> library.</li>
      <li>a <em>module</em> is a software package implementing a specific bundle. 
 This is also known as a version of a bundle.
 <em>N3.js 0.10.0</em> is a module.</li>
      <li>a <em>component</em> is a specific part of a module 
 that can be called in a certain way with a certain set of parameters.
 The <em>N3.js 0.10.0 Parser</em> is a component.</li>
    </ul>

    <p>Within this section we will focus on bundles and modules,
while components are described more in-depth in the following sections.</p>

    <h3 id="node-package-manager-npm">Node Package Manager (npm)</h3>
    <p>An example of a large collection of bundles and modules is the npm library.
It contains over 475,000 Node.js libraries,
all with their own features and requirements.
Using our terminology,
an npm package would be a bundle,
while a specific version of such a package would be a module.
The package contains the description of the project together with all its versions,
while a version contains the specific dependencies and a link to the actual implementation.</p>

    <p>All this npm data is stored in a <a href="http://couchdb.apache.org/">CouchDB</a> 
<a href="https://registry.npmjs.org/">instance</a> with one entry per bundle.
This corresponds to the metadata, added by the package developer in a <a href="https://docs.npmjs.com/files/package.json"><code>package.json</code></a> file,
with additional metadata automatically added by the npm publishing process.
To be able to uniquely identify software components and,
more importantly, interlink software components,
we converted the JSON metadata provided by the npm registry to RDF.</p>

    <h3 id="json-ld">JSON-LD</h3>
    <p>Since our input data is JSON,
it made sense to convert to <a href="http://json-ld.org/">JSON-LD</a>,
a format specifically made for adding semantics to JSON.
JSON-LD achieves this by adding a so-called <em>context</em> to the JSON data.
This context describes how the JSON tags should be interpreted.
E.g., having <code>"name": "foaf:name"</code> in your context implies
that all name tags should be interpreted as the predicate <code>foaf:name</code>.
Other JSON-LD keywords can be used to identify if certain values are URIs,
or if an entity has a specific type.
For the data where we could not reach the format using just the JSON-LD context,
such as concatenating values to create a URI,
we modified some of the input JSON before exporting it to JSON-LD.</p>

    <p class="todo">Decrease tags in examples for pages.
Probably also drop either JSON-LD or turtle</p>

    <h3 id="bundles">Bundles</h3>
    <p>A bundle represents the general npm package.
An example of a JSON representation of an npm bundle can be found at <a href="https://registry.npmjs.org/n3/">https://registry.npmjs.org/n3/</a>.
This contains all the general descriptions that apply to all bundles in this module,
such as the name, homepage and description.</p>

    <p>To adapt this JSON to RDF,
we start by adding our context,
<a href="https://linkedsoftwaredependencies.org/contexts/npm">https://linkedsoftwaredependencies.org/contexts/npm</a>,
which already maps many of the npm tags to corresponding RDF predicates.
This allows these tags to stay the same in the JSON-LD representation,
with changes required.
Due to the limitations of context mapping,
some other changes were needed,
with the most important one relating to the specific versions of the bundle.
This can be seen by calling <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3">https://linkedsoftwaredependencies.org/bundles/npm/n3</a> with the <code>"Accept: application/ld+json"</code> header or by accessing the more human friendly <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3.jsonld">URL</a>.
There the bundle now contains links to its corresponding modules,
providing semantic links between them.
Additionally, some tags were added to provide identifiers and link to the original repository.</p>

    <p>Since JSON-LD is an RDF representation it can easily be converted to other formats,
of which several are supported by our server,
such as turtle and n-triples.
These can be retrieved by sending the corresponding Accept headers.
An example of some of the data generated this way can be seen in <a href="#n3.ttl">Listing 1</a>.</p>

    <p class="todo">Bit weird to link to the listing at the end, might have to change the story up a bit somehow.</p>

    <figure id="n3.ttl" class="listing">
<pre><code>npm:n3 a doap:Project;
    dcterms:abstract &quot;Lightning fast, asynchronous, streaming...&quot;;
    dcterms:subject &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot;;
    spdx:licenseDeclared &lt;https://spdx.org/licenses/MIT.html&gt;;
    doap:release &lt;http://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&gt;;
    doap:bug-database &lt;https://github.com/RubenVerborgh/N3.js/issues&gt;;
    doap:homepage &lt;https://github.com/RubenVerborgh/N3.js#readme&gt;;
    doap:name &quot;n3&quot;;
    owl:sameAs &quot;https://www.npmjs.com/package/n3&quot;;
    foaf:maker users:rubenverborgh.
users:rubenverborgh foaf:mbox &quot;ruben.verborgh@gmail.com&quot;;
    foaf:name &quot;Ruben Verborgh&quot;.
</code></pre>
<figcaption>
        <p><span class="label">Listing 1:</span> Turtle representation of <a href="#n3.ttl">Listing 1</a>.
Prefix definitions omitted for brevity.</p>
      </figcaption>
</figure>

    <h3 id="modules">Modules</h3>
    <p>A module is a specific version of a package.
Continuing with the examples shown above,
<a href="#n3-0.10.0.json">Listing 2</a> provides some tags present
in the npm metadata of N3 version 0.10.0.
Since the general case of tags has already been covered above,
we focus on several more interesting tags in the metadata shown here.</p>

    <p>As can be seen in the JSON-LD version in <a href="#n3-0.10.0.jsonld">Listing 3</a>,
we minted several new URIs here.
In the dependencies, we now link to the semantic version <code>^2.0.1</code> 
of the async package in our own namespace.
This version corresponds to any version number of that package
that does not modify the left-most non-zero digit of the given version.
When accessing this URI,
the semantic version number will be interpreted
and a redirect will be given to the highest matching actual number.
In this case, a redirect will be given to 
<a href="https://linkedsoftwaredependencies.org/bundles/npm/async/2.4.0">https://linkedsoftwaredependencies.org/bundles/npm/async/2.4.0</a>.</p>

    <p>For the scripts we also generated new URIs.
Several scripts are predefined by npm,
meaning they get shared by many packages,
so a shared URI for those makes sense.
The actual content of the script can be accessed by accessing the new script URI,
allowing for easier automation by services that can execute these scripts.</p>

    <figure id="n3-0.10.0.json" class="listing">
<pre><code>{
    &quot;version&quot;: &quot;0.10.0&quot;,
    &quot;engines&quot;: { &quot;node&quot;: &quot;&gt;=0.10.0&quot; },
    &quot;devDependencies&quot;: { &quot;async&quot;: &quot;^2.0.1&quot; },
    &quot;scripts&quot;: { &quot;test&quot;: &quot;mocha&quot; }
}</code></pre>
<figcaption>
        <p><span class="label">Listing 2:</span> Subset of the JSON npm representation N3 version 0.10.0.</p>
      </figcaption>
</figure>

    <figure id="n3-0.10.0.jsonld" class="listing">
<pre><code>{
    &quot;@context&quot;: [
        &quot;https://linkedsoftwaredependencies.org/contexts/npm&quot;,
        { &quot;script&quot;: &quot;https://linkedsoftwaredependencies.org/scripts/npm/&quot;}
    ],
    &quot;version&quot;: &quot;0.10.0&quot;,
    &quot;engines&quot;: { &quot;node&quot;: &quot;https://linkedsoftwaredependencies.org/engines/node/%3E%3D0.10.0&quot; },
    &quot;devDependencies&quot;: { &quot;async&quot;: &quot;https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1&quot; },
    &quot;scripts&quot;: { &quot;script:test&quot;: &quot;https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0/scripts/test&quot; }
}</code></pre>
<figcaption>
        <p><span class="label">Listing 3:</span> Subset of the JSON npm representation N3 version 0.10.0.</p>
      </figcaption>
</figure>

  </section>

  <section id="describing-components">
    <h2>Describing components and their configuration</h2>

    <p>In this section, we introduce a vocabulary for describing software components and how they can be instantiated.
We provide an example of the application of this vocabulary to object-oriented software components using JavaScript.</p>

    <p class="todo">Be mentally prepared for needing to remove these figures. Idea would be to include them in the ontology, and change our ontology application so it also shows images. (That would be nice actually.)</p>

    <h3 id="object-oriented-components">Object-oriented components</h3>

    <p>Within the <a href="http://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>object-oriented components vocabulary</em></a>,
we reuse Fowler’s definition of a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-7">[7]</a> as a “glob” of software.
The purpose of a component is to provide operations that can be used by other components.
The instantiation of a component can require certain parameters,
just like object-oriented programming (OOP) languages allow constructors to have certain arguments.
In this section, we assume OOP in the broad sense of the word, which only requires <em>classes</em>, <em>objects</em> and <em>constructor parameters</em>.
<a href="#voc-oo-diagram">Fig. 2</a> shows an overview of all the classes and predicates in the components vocabulary.</p>

    <figure id="voc-oo-diagram">
<img src="voc-oo-diagram.svg" alt="[Object-oriented components vocabulary diagram]" />
<figcaption>
        <p><span class="label">Fig. 2:</span> Overview of the classes and properties in the <em>object-oriented components</em> vocabulary.</p>
      </figcaption>
</figure>

    <p>We define a <em>module</em> as a collection of components.
Within OOP languages, this can correspond to for example a software library or an application,
which can contain a multitude of functionalities, i.e., components.</p>

    <p>We define component as a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct a component can therefore be defined as an <code>rdfs:Property</code> on a component.
This class structure enables convenient semantic descriptions of components instantiations,
requiring only the fundamental concepts of RDF classes and properties.</p>

    <p>Several <code>oo:Component</code> subclasses are defined.
An <code>oo:Component</code> can be an <code>oo:Class</code>, which means that it can be instantiated based on parameters.
All instantiations of <code>oo:Class</code> instances are an <code>oo:Instance</code>.
It can also be an <code>oo:Instance</code>, meaning that it can directly be used within other components and needs no further instantiation.
An <code>oo:Class</code> can also be <code>oo:AbstractClass</code>, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicated using the <code>rdfs:subClassOf</code> predicate.</p>

    <p>The parameters that are used to instantiate an <code>oo:Class</code> to an <code>oo:Instance</code> are of type <code>oo:Parameter</code>.
An <code>oo:Parameter</code> is a <em>subclass</em> of <code>rdfs:Property</code>, which simplifies its usage as an RDF property.
<code>oo:defaultValue</code> allows parameters to have a default value when no other values have been provided.
The <code>oo:uniqueValue</code> predicate is a flag that can be set to indicate whether or not the parameter can only have a single value.</p>

    <p><a href="#module-n3">Listing 4</a> shows an example of the N3.js npm module using the components vocabulary.
It exposes several components such as <em>Parser</em> and <em>Lexer</em>.
Each of these components can take several different parameters.
<a href="#config-n3">Listing 5</a> illustrates how instances can be created of these component types.</p>

    <figure id="module-n3" class="listing">
<pre><code>ex:n3 a oo:Module; oo:hasComponents n3:Parser, n3:Lexer.
n3:Parser a oo:Class oo:hasParameter
    n3:format, n3:blankNodePrefix, n3:lexer, n3:explicitQuantifiers.
n3:Lexer  a oo:Class oo:hasParameter
    n3:lineMode, n3:n3, n3:comments;

n3:format              a oo:Parameter; rdfs:range xsd:string.
n3:blankNodePrefix     a oo:Parameter; rdfs:range xsd:string.
n3:lexer               a oo:Parameter; rdfs:range n3:Lexer.
n3:explicitQuantifiers a oo:Parameter; rdfs:range xsd:boolean.
n3:lineMode            a oo:Parameter; rdfs:range xsd:boolean.
n3:n3                  a oo:Parameter; rdfs:range xsd:boolean.
n3:comments            a oo:Parameter; rdfs:range xsd:boolean.</code></pre>
<figcaption>
        <p><span class="label">Listing 4:</span> The N3.js module contains a parser, lexer and util component.
The parser and lexer are a constructable components.
The parser has a parameter that takes another component, a lexer, as input.
The util component already is an instance, for which it needs no parameters.</p>
      </figcaption>
</figure>

    <figure id="config-n3" class="listing">
<pre><code>ex:myLexer a n3:Lexer;
    n3:comments &quot;true&quot;^^xsd:boolean.

ex:myParser a n3:Parser;
    n3:format &quot;application/trig&quot;;
    n3:lexer ex:myLexer.</code></pre>
<figcaption>
        <p><span class="label">Listing 5:</span> <code>ex:myLexer</code> is a lexer that accepts comments.
<code>ex:myParser</code> is a parser that accepts the TriG format and uses <code>ex:myLexer</code> for lexing.</p>
      </figcaption>
</figure>

    <p class="todo">mention reasoning for checking things like valid parameter range</p>

    <h3 id="object-mapping">Object mapping</h3>

    <p>A consequence of using RDF to instantiate components is that the parameters have no fixed order.
While this is sufficient to describe component instantiations on a semantic level,
it is insufficient for mapping parameter values to arguments in method and constructor calls that are based on a fixed ordering for parameters,
which is the case for most popular OOP languages.</p>

    <p>We introduce a new vocabulary for describing the mapping between the pure semantic parameters
to arguments in method calls in OOP languages like JavaScript, hence the name <a href="http://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>object mapping vocabulary</em></a>.
<a href="#voc-om-diagram">Fig. 3</a> shows an overview of all the classes and predicates in the components vocabulary.</p>

    <figure id="voc-om-diagram">
<img src="voc-om-diagram.svg" alt="[Object mapping vocabulary diagram]" />
<figcaption>
        <p><span class="label">Fig. 3:</span> Overview of the classes and properties in the <em>object mapping</em> vocabulary.</p>
      </figcaption>
</figure>

    <p>Our vocabulary introduces the <em>object map</em> and the <em>array map</em>, the latter is a subclass of the former.
An object map can have several <em>object map entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array map entries</em>, each entry only has a value.</p>

    <p class="todo">Consider dropping all listings in this section, we’ll need to keep the explanation conceptual there. People will need to understand <em>why</em> mappings are needed, understand high-level <em>what</em> they do, but the <em>how</em> might not be possible to explain.</p>

    <p>If the value of <code>om:fieldName</code> or <code>om:fieldValue</code> is a literal, the literal value will be mapped to the object field name or value.
An <code>om:fieldValue</code> can also refer to another object map, which will be mapped to the resulting object.
<code>om:collectsEntriesFrom</code> can refer to a predicate that points to entities with certain predicates.
Each entity predicate that is refered to by <code>om:fieldName</code> will have its values mapped to keys of the object.
Each entity predicate refered to by <code>om:fieldValue</code> will have its values mapped to values.
<a href="#om-collects-module">Listing 6</a>, <a href="#om-collects-data">Listing 7</a> and <a href="#om-collects-result">Listing 8</a> show an example of this entry collection process.</p>
    <figure id="om-collects-module" class="listing">
<pre><code>:myOm om:hasField [
    om:fieldName foaf:name;
    om:fieldValue: foaf:mbox.
    om:collectsEntriesFrom foaf:knows.
].</code></pre>
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 6:</span> An object mapping for mapping all <code>foaf:knows</code> resources to an object
with as key the <code>foaf:name</code> and as value the <code>foaf:mbox</code>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-data" class="listing">
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<figcaption>
        <p><span class="label">Listing 7:</span> All the people <code>:me</code> knows using the <a href="http://xmlns.com/foaf/spec/">FOAF vocabulary</a>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-result" class="listing">
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 8:</span> The resulting object when mapping the people <code>:me</code> knows from <a href="#om-collects-data">Listing 7</a>
using the object mapping from <a href="#om-collects-module">Listing 6</a>.</p>
      </figcaption>
</figure>

    <p><a href="#module-n3-mapped">Listing 9</a> shows the mapping of the N3.js component parameters to the constructor implementations.
This description enchances the component definitions from <a href="#module-n3">Listing 4</a>
as it provides a lower level (implementation) view on the component constructors.</p>

    <figure id="module-n3-mapped" class="listing">
<pre><code>n3:Parser oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;format&quot;;
        om:fieldValue: n3:format.
    ],
    [
        om:fieldName &quot;blankNodePrefix&quot;;
        om:fieldValue: n3:blankNodePrefix.
    ],
    [
        om:fieldName &quot;lexer&quot;;
        om:fieldValue: n3:lexer.
    ],
    [
        om:fieldName &quot;explicitQuantifiers&quot;;
        om:fieldValue: n3:explicitQuantifiers.
    ].
]).

n3:Lexer oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;lineMode&quot;;
        om:fieldValue: n3:lineMode.
    ],
    [
        om:fieldName &quot;n3&quot;;
        om:fieldValue: n3:n3.
    ],
    [
        om:fieldName &quot;comments&quot;;
        om:fieldValue: n3:comments.
    ].
]).</code></pre>
<figcaption>
        <p><span class="label">Listing 9:</span> Both the parameters of the parser and lexer component are respectively mapped to an object.
These objects are the single arguments of respectively the parser and lexer constructor.
The field value in this case is always a parameter.</p>
      </figcaption>
</figure>

  </section>

  <section id="instantiating">
    <h2>Instantiating component configurations</h2>

    <p class="todo">mention closing of the world</p>

    <p>In the previous section, we introduced a vocabulary for describing software components and how they can be instantiated.
In this section, we introduce a dependency injection framework based on these component descriptions.
With this, we take semantic software component descriptions to the next level,
we don’t only <em>describe</em> components, but also allow them to be <em>instantiated</em>.</p>

    <p>We have implemented, <a href="https://github.com/LinkedSoftwareDependencies/Components.js">Components.js</a>,
an open-source dependency injection framework for JavaScript, and made it available on <a href="https://www.npmjs.com/package/lsd-components">npm</a>.
It is able to construct component instances based on declarative component constructions in RDF using the vocabulary introduced in <a href="#describing-components">Section 5</a>.
It accepts raw triple streams or URL’s to RDF documents containing these declarations.
At the time of writing, the parser accepts RDF documents serialized in either JSON-LD, Turtle, TriG, N-Triples or N-Quads.</p>

    <p><a href="#components.js">Listing 10</a> illustrates how components can be instantiated using Components.js.
It provides a <code>Loader</code> class that acts as an assembler when instantiated.
This <code>Loader</code> is based on the principles of <em>Constructor injection</em>, as explained in <a href="#related-work-dependency-injection">Subsection 2.3</a>
It dynamically calls the constructor of the component and passes the configured parameters in a single object argument.
If a constructor mapping is detected, the parameter values will be mapped to constructor arguments as configured by the mapping.
Additionally, <a href="https://github.com/LinkedSoftwareDependencies/Components.js#component-configuration-unnamed">simplified mechanisms</a>
are in place for developers that want to use the dependency injector directly without having to semantically describe the component.</p>

    <figure id="components.js" class="listing">
<pre><code>const loader = new require(&#39;lsd-components&#39;).Loader();
loader.registerModuleResourcesUrl(&#39;http://example.org/module-n3.ttl&#39;)
loader.registerConfigUrl(&#39;http://example.org/config-n3.ttl&#39;)
var myParser = loader.instantiate(&#39;http://example.org/config-n3.ttl#myParser&#39;);</code></pre>
<figcaption>
        <p><span class="label">Listing 10:</span> First, a new component loader is created
after which module and component definitions are registered.
Finally, a declarative component instantiation is supplied by providing the component URI
and the location at which the resource can be found.</p>
      </figcaption>
</figure>

  </section>

  <section id="use-case">
    <h2>Use case: a Linked Data Fragments experiment</h2>

    <p class="todo">Sarven, Joachim, Ruben V. write this</p>

    <p><a property="http://purl.org/spar/cito/citesAsAuthority" href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments</a> <a class="reference" href="#ref-11">[11]</a></p>

    <p>We have implemented a new version of the <a href="https://github.com/LinkedDataFragments/Server.js/tree/feature-lsd">LDF server</a>
where all components are dynamically wired by Components.js.
We semantically describe the LDF server module and its 32 components, which results in x triples.
The configuration file used to be a <a href="https://github.com/LinkedDataFragments/Server.js/blob/master/config/config-example.json">JSON file</a>
with a custom domain-specific language.
Now, this <a href="https://github.com/LinkedDataFragments/Server.js/blob/feature-lsd/config/config-example.json">configuration file</a> is a declarative components file that can be understood by Components.js,.
This new configuration format has two major advantages:</p>

    <ul>
      <li>The configuration file is RDF data with a semantic meaning.</li>
      <li>External components can be injected by including declaratively into the config file.</li>
    </ul>

    <p class="todo">count triples</p>

  </section>

  <section id="conclusion">
    <h2>Conclusion</h2>

    <p class="todo">Write</p>

    <p class="todo">Mention autogeneration of component files in future work</p>

  </section>

</main>

<footer>
      <section id="footnotes">
        <h2>Footnotes</h2>
        <ol>
    <li id="fn:HollywoodPrinciple">
      <p>This concept is also know as the Hollywood Principle <a class="reference" href="#ref-10">[10]</a>: <q>Don’t call us, we’ll call you</q>&nbsp;<a href="#fnref:HollywoodPrinciple" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
      </section>
    <section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd>Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd>Berners-Lee, T.: Linked Data, <a href="https://www.w3.org/DesignIssues/LinkedData.html,">https://www.w3.org/DesignIssues/LinkedData.html,</a> (2009).</dd>
  <dt id="ref-3">[3]</dt>
  <dd>Berners-Lee, T.: Information Management: A Proposal, <a href="https://www.w3.org/History/1989/proposal.html,">https://www.w3.org/History/1989/proposal.html,</a> (1989).</dd>
  <dt id="ref-4">[4]</dt>
  <dd>Rietveld, L., Beek, W., Schlobach, S.: LOD Lab: Experiments at LOD Scale. In: Arenas, M., Corcho, O., Simperl, E., Strohmaier, M., d’Aquin, M., Srinivas, K., Groth, P., Dumontier, M., Heflin, J., Thirunarayan, K., and Staab, S. (eds.) Proceedings of the 14th International Semantic Web Conference. pp. 339–355. Springer (2015).</dd>
  <dt id="ref-5">[5]</dt>
  <dd>Rautenberg, S., Ermilov, I., Marx, E., Auer, S., Ngomo, A.-C.N.: LODFlow: A Workflow Management System for Linked Data Processing. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 137–144. ACM, New York, NY, USA (2015).</dd>
  <dt id="ref-6">[6]</dt>
  <dd>Hürsch, W.L., Lopes, C.V.: Separation of concerns. (1995).</dd>
  <dt id="ref-7">[7]</dt>
  <dd>Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern, <a href="https://martinfowler.com/articles/injection.html,">https://martinfowler.com/articles/injection.html,</a> (2004).</dd>
  <dt id="ref-8">[8]</dt>
  <dd>Fowler, M.: InversionOfControl, <a href="https://martinfowler.com/bliki/InversionOfControl.html,">https://martinfowler.com/bliki/InversionOfControl.html,</a> (2005).</dd>
  <dt id="ref-9">[9]</dt>
  <dd>Johnson, R.E., Foote, B.: Designing reusable classes. Journal of object-oriented programming. 1, 22–35 (1988).</dd>
  <dt id="ref-10">[10]</dt>
  <dd>Sweet, R.E.: The Mesa programming environment. In: ACM SIGPLAN Notices. pp. 216–229. ACM (1985).</dd>
  <dt id="ref-11">[11]</dt>
  <dd>Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, 184–206 (2016).</dd>
</dl>
</section>
</footer>





</body>
</html>
