<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Reproduceable software experiments through semantic configurations</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css">
  <link rel="stylesheet" media="print"  href="styles/print.css">
</head>
<body>
  <header>
  <h1 id="reproduceable-software-experiments-through-semanticconfigurations">Reproduceable software experiments through semantic configurations</h1>

  <ul id="authors">
    <li>Ruben Taelman<a href="#idlab"><sup>1</sup></a></li>
    <li>Joachim Van Herwegen<a href="#idlab"><sup>1</sup></a></li>
    <li>Sarven Capadisli<a href="#eisd"><sup>2</sup></a></li>
    <li>Ruben Verborgh<a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
    <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The scientific process requires reproducible experiments and findings
to foster trust and accountability.
Within computer science engineering,
reproducing experiments involves setting up
the exact same software with the same benchmarks and test data,
which often requires non-trivial manual work.
<!-- Need         -->
Unfortunately,
many research articles ambiguously refer to software by name only,
leaving out crucial details such as module and dependency version numbers
or the configuration of the individual components.
<!-- Task         -->
To this end, we created vocabularies
for the semantic description of software components and their configuration,
which can be published as Linked Data alongside experimental results.
We implemented a dependency injection framework
to accurately instantiate these described experimental configurations.
<!-- Object       -->
This article discusses the approach and its application,
and explains with a use case
how to publish experiments and their software configurations on the Web.
<!-- Findings     -->
In order to enable semantic interlinking between configurations and modules,
we published the metadata of all 475,000+ JavaScript libraries on npm
as 150,000,000+ RDF triples.
<!-- Conclusion   -->
Through our work,
research articles can refer by URL
to fine-grained, instantiatable descriptions of experimental setups,
completing the provenance chain from
specifications to implementations, dependencies, and configurations
all the way to experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.
<!-- Perspectives -->
Moreover, this work can serve other use cases,
such as general software instantiation outside of experiments,
and query execution over software configuration metadata.</p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>
    <p>Too many computer science articles
that contain experimental software evaluations
identify that software only by name and, sometimes, version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which exact versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has in fact obtained the reported results.
Therefore, potential users cannot necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any of these aspects.</p>

    <p>As <a property="http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a class="reference" href="#ref-1">[1]</a> explains,
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment, the involved artefacts and actors,
and the processing of the retrieved data.</p>

    <p>Using Linked Data to publish such descriptions provides two immediate benefits:
the experimental setup and parts thereof can be <em>identified with IRIs</em>,
and their details can be retrieved by <em>dereferencing those IRIs</em>.
Therefore, if research articles complement their textual explanation of an experiment
with the IRI of the full setup, reproducibility is guaranteed</p>

    <p class="todo">“Guaranteed” may be too strong?</p>
    <p>Moreover, the IRIs of the entire experiment or its parts
can be reused in other articles or experiment
to unambiguously refer to the same conditions.
<a href="#description-diagram">Fig. 1</a> illustrates how this leads to a chain of provenance
from the research article to the data
and the experiment that generates it,
and all the aspects surrounding that experiment.</p>

    <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
        <p>A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article focuses on <em>software configurations</em> and <em>software modules</em>.</p>
      </figcaption>
</figure>

    <p>In this article,
we focus on the description of <em>software configurations</em> and <em>software modules</em>,
such that an evaluated software setup
can be referred to unambiguously by an IRI.
We thereby avoid the inherent vagueness
of referring to software by name only.
We further facilitate the reproduction of experiments
through a mechanisms that automatically <em>instantiates</em> the software configuration
based on its Linked Data description.
Our contributions are the following:</p>

    <ul>
      <li>the RDF-based description of <strong>software modules</strong>,
applied to the 475,000+ bundles of the npm ecosystem for Node.js;</li>
      <li>the RDF-based description of <strong>available components</strong> within software modules;</li>
      <li>the RDF-based description of a <strong>precise configuration</strong> of software modules;</li>
      <li>the <strong>automated instantiation</strong> of such a configuration;</li>
      <li>a <strong>use case</strong> explaining the usage of the resulting Linked Data
in scientific articles.</li>
    </ul>

    <p>{:.todo} Would a figure explaining the relation between module, component, configuration and instance be useful here?</p>
  </section>

  <section id="related-work">
    <h2>Related Work</h2>
    <p class="todo">Introduce section structure</p>

    <h3 id="scholarly-publishing-and-reproducibility">Scholarly publishing and reproducibility</h3>
    <p class="todo">Sarven will start this</p>

    <p class="todo">We should cite <a property="http://purl.org/spar/cito/cites" href="http://laurensrietveld.nl/pdf/lodlab.pdf">LOD Lab</a> <a class="reference" href="#ref-2">[2]</a>,
as they brought a major new angle to reproducibility within the Semantic Web.
Should also look at their argumentation.</p>

    <h3 id="ontologies-and-vocabularies-for-describing-experiments">Ontologies and vocabularies for describing experiments</h3>
    <p class="todo">Sarven will start this</p>

    <h3 id="dependency-injection">Dependency injection</h3>
    <p class="todo">Ruben T. writes this, asks Ruben V. for references</p>

  </section>

  <section id="overview-of-software-experiment-descriptions">
    <h2>Overview of software experiment descriptions</h2>
    <p class="todo">This section will shortly introduce each of the blocks in the diagram.
Ruben V. will write the basis.</p>

    <p class="todo">Mention somewhere here that we will use JSON-LD syntax for the examples in this paper.</p>

    <h4 id="specification">Specification</h4>
    <p class="todo">Write</p>

    <h4 id="module">Module</h4>
    <p class="todo">Write</p>

    <p class="todo">A module consists of <em>components</em></p>

    <h4 id="configuration">Configuration</h4>
    <p class="todo">Write</p>

    <h4 id="experiment">Experiment</h4>
    <p class="todo">Write</p>

    <h4 id="results">Results</h4>
    <p class="todo">Write</p>

    <h4 id="article">Article</h4>
    <p class="todo">Write</p>

  </section>

  <section id="describing-software-modules">
    <h2>Describing software modules</h2>
    <p class="todo">Joachim writes this</p>

  </section>

  <section id="describing-components-and-their-configuration">
    <h2>Describing components and their configuration</h2>
    <p class="todo">Ruben T. writes this</p>

    <p>In this section, we introduce a vocabulary for describing software components and how they can be instantiated.
We provide an example of the application of this vocabulary to object-oriented software components using JavaScript.</p>

    <h3 id="components">Components</h3>

    <p>Within the components vocabulary, we define a software <em>component</em> as <em>either a software class that can be instantiated or an instance</em>.
The purpose of a component is to provide operations that can be used by other components.
In object-oriented programming (OOP), a component could therefore be either an <em>object</em>, <em>object factory</em> or the <em>constructor of a class</em>.
The instantiation of a component can require certain parameters, just like OOP languages allow constructors to have certain arguments.</p>

    <p class="todo">link to voc</p>

    <p>A <em>module</em> is a collection of components.
Within OOP languages, this can correspond to a software library or an application,
which can contain a multitude of functionalities, i.e., components.</p>

    <p>We define a component as a <em>subtype</em> of <code>rdfs:Class</code>.
The parameters of a component can therefore be defined as an <code>rdfs:Property</code> on a component.
This simple component structure enables convenient semantic descriptions of components instantiations,
requiring only the fundamental concepts of RDF classes and properties.</p>

    <p>Figure TODO shows an overview of all the classes and predicates in the components vocabulary.</p>

    <p class="todo">figure</p>

    <p>Several component subtypes are defined.
A component can be constructable, which means that it requires some form of instantiation before it can be used elsewhere.
It can also be a direct instance, meaning that it can directly be used within other components and needs no further instantiation.
A component can also be abstract, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicating using the <code>rdfs:subClassOf</code> predicate.</p>

    <p class="todo">Say some things about parameters once the vocabulary on this has been fixed.</p>

    <p><a href="#module-n3">Fig. 2</a> shows an example of the N3.js npm module using the components vocabulary.
It exposes several components such as <em>Parser</em> and <em>Lexer</em>.
Each of these components can take several different parameters.
<a href="#config-n3">Fig. 3</a> illustrates how instances can be created of these component types.</p>

    <figure id="module-n3">
<pre><code>ex:n3 a lsdc:Module;
    lsdc:hasComponents
        n3:Parser,
        n3:Lexer.

n3:Parser a lsdc:ComponentConstructable
    lsdc:hasParameter n3:format,
        n3:blankNodePrefix,
        n3:lexer,
        n3:explicitQuantifiers.

n3:format a lsdc:Parameter;
    rdfs:range xsd:string.
n3:blankNodePrefix a lsdc:Parameter;
    rdfs:range xsd:string.
n3:lexer a lsdc:Parameter;
    rdfs:range n3:Lexer.
n3:explicitQuantifiers a lsdc:Parameter;
    rdfs:range xsd:boolean.

n3:Lexer a lsdc:ComponentConstructable
    lsdc:hasParameter n3:lineMode,
        n3:n3,
        n3:comments;

n3:lineMode a lsdc:Parameter;
    rdfs:range xsd:boolean.
n3:n3 a lsdc:Parameter;
    rdfs:range xsd:boolean.
n3:comments a lsdc:Parameter;
    rdfs:range xsd:boolean.</code></pre>
<figcaption>
        <p>The N3.js module contains a parser, lexer and util component.
The parser and lexer are a constructable components.
The parser has a parameter that takes another component, a lexer, as input.
The util component already is an instance, for which it needs no parameters.</p>
      </figcaption>
</figure>

    <figure id="config-n3">
<pre><code>ex:myLexer a n3:Lexer;
    n3:comments &quot;true&quot;^^xsd:boolean.

ex:myParser a n3:Parser;
    n3:format &quot;application/trig&quot;;
    n3:lexer ex:myLexer.</code></pre>
<figcaption>
        <p><code>ex:myLexer</code> is a lexer that accepts comments.
<code>ex:myParser</code> is a parser that accepts the TriG format and uses <code>ex:myLexer</code> for lexing.</p>
      </figcaption>
</figure>

    <h3 id="object-oriented-components">Object-oriented components</h3>

    <p>A consequence of using RDF to instantiate components is that the parameters have no fixed order.
While this is sufficient to describe component instantiations on a semantic level,
it is insufficient for mapping parameter values to arguments in method and constructor calls that are based on a fixed ordering for parameters,
which is the case for most popular programming languages.</p>

    <p>We introduce a new vocabulary for describing the mapping between the pure semantic parameters
to arguments in method calls in OOP languages like JavaScript, hence the name <em>object mapping vocabulary</em>.</p>

    <p class="todo">link to voc</p>

    <p>Our vocabulary introduces the <em>object map</em> and the <em>array map</em>, the latter is a subclass of the former.
An object map can have several <em>object map entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array map entries</em>, each entry only has a value.</p>

    <p>Figure TODO shows an overview of all the classes and predicates in the components vocabulary.</p>

    <p>If the value of <code>fieldName</code> or <code>fieldValue</code> is a literal, the literal value will be mapped to the object field name or value.
A <code>fieldValue</code> can also refer to another object map, which will be mapped to the resulting object.
An object map can be dynamic, where the object field names and values can be mapped dynamically based on predicates.</p>

    <p><a href="#module-n3-mapped">Fig. 4</a> shows the mapping of the N3.js component parameters to the constructor implementations.
This description enchances the component definitions from <a href="#module-n3">Fig. 2</a>
as it provides a lower level (implementation) view on the component constructors.</p>

    <figure id="module-n3-mapped">
<pre><code>n3:Parser lsdc:constructorMapping ([
    om:hasField [
        om:fieldName &quot;format&quot;;
        om:fieldValue: n3:format.
    ],
    [
        om:fieldName &quot;blankNodePrefix&quot;;
        om:fieldValue: n3:blankNodePrefix.
    ],
    [
        om:fieldName &quot;lexer&quot;;
        om:fieldValue: n3:lexer.
    ],
    [
        om:fieldName &quot;explicitQuantifiers&quot;;
        om:fieldValue: n3:explicitQuantifiers.
    ].
]).

n3:Lexer lsdc:constructorMapping ([
    om:hasField [
        om:fieldName &quot;lineMode&quot;;
        om:fieldValue: n3:lineMode.
    ],
    [
        om:fieldName &quot;n3&quot;;
        om:fieldValue: n3:n3.
    ],
    [
        om:fieldName &quot;comments&quot;;
        om:fieldValue: n3:comments.
    ].
]).</code></pre>
<figcaption>
        <p>Both the parameters of the parser and lexer component are respectively mapped to an object.
These objects are the single arguments of respectively the parser and lexer constructor.
The field value in this case is always a parameter.</p>
      </figcaption>
</figure>

  </section>

  <section id="instantiating-component-configurations">
    <h2>Instantiating component configurations</h2>
    <p class="todo">Ruben T. writes this.</p>

  </section>

  <section id="use-case-alinked-data-fragments-experiment">
    <h2>Use case: a Linked Data Fragments experiment</h2>
    <p class="todo">Sarven, Joachim, Ruben V. write this</p>

    <p><a property="http://purl.org/spar/cito/citesAsAuthority" href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments</a> <a class="reference" href="#ref-3">[3]</a></p>

  </section>

  <section id="conclusion">
    <h2>Conclusion</h2>
    <p class="todo">Write</p>

  </section>

<section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd>Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd>Rietveld, L., Beek, W., Schlobach, S.: LOD Lab: Experiments at LOD Scale. In: Arenas, M., Corcho, O., Simperl, E., Strohmaier, M., d’Aquin, M., Srinivas, K., Groth, P., Dumontier, M., Heflin, J., Thirunarayan, K., and Staab, S. (eds.) Proceedings of the 14th International Semantic Web Conference. pp. 339–355. Springer (2015).</dd>
  <dt id="ref-3">[3]</dt>
  <dd>Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, 184–206 (2016).</dd>
</dl>
</section>
</main>



</body>
</html>
