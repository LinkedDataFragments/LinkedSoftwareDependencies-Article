<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta charset="utf-8" />
  <title>Components.js: a semantic dependency injection framework for addressable and discoverable software configurations</title>
  <link href="styles/screen.css" media="screen" rel="stylesheet" title="IDLab" />
  <link href="styles/print.css"  media="print"  rel="stylesheet" />
  <link href="https://fonts.googleapis.com/css?family=Ubuntu+Mono" rel="stylesheet" />
  <link href="https://dokie.li/media/css/do.css" media="all" rel="stylesheet" />
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" media="all" rel="stylesheet" />
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://dokie.li/scripts/simplerdf.js"></script>
  <script src="https://dokie.li/scripts/medium-editor.min.js"></script>
  <script src="https://dokie.li/scripts/medium-editor-tables.min.js"></script>
  <script src="https://dokie.li/scripts/do.js"></script>
</head>
<body about="" prefix="rdf: http://www.w3.org/1999/02/22-rdf-syntax-ns# rdfs: http://www.w3.org/2000/01/rdf-schema# owl: http://www.w3.org/2002/07/owl# xsd: http://www.w3.org/2001/XMLSchema# dcterms: http://purl.org/dc/terms/ dctypes: http://purl.org/dc/dcmitype/ foaf: http://xmlns.com/foaf/0.1/ v: http://www.w3.org/2006/vcard/ns# pimspace: http://www.w3.org/ns/pim/space# cc: https://creativecommons.org/ns# skos: http://www.w3.org/2004/02/skos/core# prov: http://www.w3.org/ns/prov# qb: http://purl.org/linked-data/cube# schema: http://schema.org/ void: http://rdfs.org/ns/void# rsa: http://www.w3.org/ns/auth/rsa# cert: http://www.w3.org/ns/auth/cert# cal: http://www.w3.org/2002/12/cal/ical# wgs: http://www.w3.org/2003/01/geo/wgs84_pos# org: http://www.w3.org/ns/org# biblio: http://purl.org/net/biblio# bibo: http://purl.org/ontology/bibo/ book: http://purl.org/NET/book/vocab# ov: http://open.vocab.org/terms/ sioc: http://rdfs.org/sioc/ns# doap: http://usefulinc.com/ns/doap# dbr: http://dbpedia.org/resource/ dbp: http://dbpedia.org/property/ sio: http://semanticscience.org/resource/ opmw: http://www.opmw.org/ontology/ deo: http://purl.org/spar/deo/ doco: http://purl.org/spar/doco/ cito: http://purl.org/spar/cito/ fabio: http://purl.org/spar/fabio/ oa: http://www.w3.org/ns/oa# as: https://www.w3.org/ns/activitystreams# ldp: http://www.w3.org/ns/ldp# solid: http://www.w3.org/ns/solid/terms# acl: http://www.w3.org/ns/auth/acl# dio: https://w3id.org/dio#" typeof="schema:CreativeWork sioc:Post prov:Entity">

  <main>
<article about="" typeof="schema:Article">
    <header>
      <h1 id="componentsjs-a-semantic-dependency-injection-framework-for-addressable-and-discoverable-software-configurations">Components.js: a semantic dependency injection framework for addressable and discoverable software configurations</h1>

      <ul id="authors">
        <li><a href="http://www.rubensworks.net/" rel="schema:author" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a><a href="#idlab"><sup>1</sup></a></li>
        <li><a href="#" rel="schema:author" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a><a href="#idlab"><sup>1</sup></a></li>
        <li><a href="http://csarven.ca/" rel="schema:author" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://csarven.ca/#i">Sarven Capadisli</a><a href="#eisd"><sup>2</sup></a></li>
        <li><a href="#" rel="schema:author" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/miel_vander_sande">Miel Vander Sande</a><a href="#idlab"><sup>1</sup></a></li>
        <li><a href="https://ruben.verborgh.org/" rel="schema:author" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a><a href="#idlab"><sup>1</sup></a></li>
      </ul>

      <ul id="affiliations">
        <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
        <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
      </ul>

      <section id="abstract">
        <h2>Abstract</h2>
        <!-- Context      -->
        <p>In empirical software engineering,
replications provide knowledge on what results hold under which conditions.
Often, these ought to be exact: the experimental procedures and their accompanying software are matched as closely as possible.
<!-- Need         -->
Because different algorithms, or implementations thereof, need to be easily swappable in a transparent manner,
a dependency injection design benefits experimental software.
Various wiring of independent components can be created, tested, and compared—even through means of static program analysis.
Within the Semantic Web,
the opportunity exists to move beyond the local scope of existing dependency injection frameworks and 
facilitate exact replication on the Web with addressable, dereferenceable, and unambiguous software configurations.
<!-- Task         -->
Therefore, 
we introduce Components.js, a semantic dependency injection framework for JavaScript,
that (i) describes software components using a Object-Oriented Components and Object Mapping ontology, 
(ii) automatically instantiates experimental configurations using linking and dereferencing, and
(iii) is complementary to the modular programming of package managers.
<!-- Object       -->
This article presents the framework, 
its application, 
and incorporates a proof of concept on discovery of experimental software configurations on the Web.
<!-- Findings     -->
All 600,000+ Node Package Manager libraries were described
as more than 300 million RDF triples, which interlink different modules.
Thereby, a set of queries provide insights like what experiments use the same algorithm, 
or the different implementations of the same function.
<!-- Conclusion   -->
Components.js enables research articles to complete the provenance chain of experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.</p>

      </section>

      <section class="actions">
        <h2 id="notifications-and-annotations">Notifications and annotations</h2>
        <ul>
          <li><a href="https://linkedresearch.org/inbox/linkedresearch.org/localhost/" rel="ldp:inbox">notification inbox</a></li>
          <li><a href="https://linkedresearch.org/annotation/linkedresearch.org/localhost/" rel="oa:annotationService">annotation service</a></li>
        </ul>
      </section>

      <section class="context">
        <h2 id="in-reply-to">In reply to</h2>
        <ul>
          <li><a href="https://linkedresearch.org/calls" rel="as:inReplyTo">Call for Linked Research</a></li>
          <li><a href="http://iswc2018.semanticweb.org/call-for-resources-track-papers/" rel="as:inReplyTo">ISWC2018 call for resources track</a></li>
        </ul>
      </section>

    </header>

    <section id="introduction">
      <h2>Introduction</h2>

      <p>Among the many fields conveyed by the Semantic Web domain, 
empirical software engineering <a href="#ref-1" class="reference">[1]</a><a href="#ref-2" class="reference">[2]</a> is undeniably prominent.
Here, research concerns itself with <q>empirical observation of software engineering artifacts and the empirical validation of software engineering theories
and assumptions</q> <a href="#ref-3" class="reference">[3]</a>,
thus relieving tension between the curiosity-driven <em>science</em> and the utility-driven <em>engineering</em>.
Evidently,
this includes developing software in a way that improves <em>reporting</em>, i.e., supporting a systematic, standardized presentation of empirical research in publications <a href="#ref-4" class="reference">[4]</a>,
and conducting <em>controlled experiments</em>, i.e., testing hypotheses where one or more independent variables (treatment) are manipulated to measure their effect on one or more dependent variables (e.g., execution time, etc.) <a href="#ref-5" class="reference">[5]</a>.
Experimental software therefore preferably supports the exact replication of experimental procedures <a href="#ref-6" class="reference">[6]</a>, 
which keep the conditions of the experiment <em>dependent</em> (all remain the same or very similar),
or <em>independent</em> (one or more major aspects are deliberately varied).</p>

      <p>Rather than obscuring experimental software in monolithic, non-transparent packages—often referred to in an ambiguous way by only name or version number—different algorithms and implementations thereof need to be easily swappable in a transparent manner.
The latter is embodied by the <a property="schema:citation http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> <a href="#ref-7" class="reference">[7]</a> pattern,
where instead of custom code, a generic framework—the <em>assembler</em>—determines the flow of control and calls upon individual <em>software components</em> when needed.
Such components are
<q>globs of software that are intended to be used, without change, by an application that is out of the control of the writers of the component</q> <a href="#ref-7" class="reference">[7]</a>,
and can be defined and injected independently.
An external configuration document specifies the wiring of these components during the <em>configuration phase</em>, 
which is used by the assembler to perform the actual instantiation during the <em>injection phase</em>.
With the Semantic Web in mind,
these configurations could move beyond their local scope,
and also improve in reporting to help finding the right experiment, understanding how it is conducted, and assess the validity of its results <a href="#ref-4" class="reference">[4]</a>.</p>

      <p>To this end, 
we present <em>Components.js</em>, 
a semantic dependency Injection framework for JavaScript applications that makes software configuration <em>addressable</em> and <em>discoverable</em>, hence surpassing existing dependency injection frameworks.
The framework is <a href="https://github.com/LinkedSoftwareDependencies/Components.js">open-source</a>, available on <a href="https://www.npmjs.com/package/componentsjs">npm</a>, and its complete documentation can be found at <a href="https://componentsjs.readthedocs.io/">https:/​/​componentsjs.readthedocs.io/</a>.
Software configurations and modules are described as Linked Data using the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://linkedsoftwaredependencies.org/articles/describing-experiments/"><em>Object-Oriented Components ontology</em></a> <a href="#ref-8" class="reference">[8]</a> and the introduced <em>Object Mapping ontology</em>.
By publishing such descriptions,
the composition of experimental software (and parts thereof) can be <em>unambiguously identified</em> by IRIs and 
retrieved through <em>dereferencing</em>.
Components.js automatically <em>instantiates</em> such software configurations, including resolving the necessary dependencies, 
and is fully compatible with the modular programming approach.
In total, this entails the following benefits:
(i) extended reporting of experiments in research articles by IRI;
(ii) improved transparency and replication of experimental software;
(iii) facilitation of static program analysis through the use of external, semantic configuration files;
(iv) a joint data space of research articles and experimental software, enabling discoverable and queryable links between research and implementations.</p>

      <p>Finally, we include a proof of-concept based on the Node.js package manager <a href="https://www.npmjs.com/">npm</a>.
An RDF-based description was generated for 600,000+ packages. Thereby, 
we demonstrate the description of an existing application and its available components (available as modules),
the automated instantiation of such a configuration, and the discoverability with a set of insightful queries.
Note that, although this is a JavaScript implementation, the principles are generalizable, 
can be implemented in other languages, or can improve cross-language replication of software.</p>

    </section>

    <section id="related-work">
      <h2>Related Work</h2>

      <p>In this section, we discuss existing description methods or ontologies to describe software, 
and position them to the Object-Oriented Components ontology, which is described in the next section.
In addition, we describe other dependency injection frameworks, both for JavaScript and other languages,
and discuss their limitations compared to Components.js.</p>

      <h3 id="semantic-software-description">Semantic software description</h3>

      <p>Software can be described on several levels of granularity,
going from a high-level package overview to a low-level description of the actual code.
The Software Ontology (SWO) <a href="#ref-9" class="reference">[9]</a> and <a property="schema:citation http://purl.org/spar/cito/cites" href="http://usefulinc.com/ns/doap">Description of a Project (DOAP)</a> <a href="#ref-10" class="reference">[10]</a> ontology focus on the high-level management of software development,
enabling the description of tools, resources, contributors and tasks. 
At a slightly lower level, SWO includes interfaces, algorithms, versions, and the associated provenance data, but does not reach the level of detail to describe operational code.</p>

      <p>Ontologies that describe software configuration from a research workflow perspective are <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1145/2814864.2814882"><a href="http://svn.aksw.org/papers/2015/SEMANTICS_LDWPO/public.pdf">LODFlow</a></span> <a href="#ref-11" class="reference">[11]</a>, <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1016/j.websem.2015.01.003"><a href="https://doi.org/10.1016/j.websem.2015.01.003">Workflow-Centric Research Objects</a></span> <a href="#ref-12" class="reference">[12]</a> with the <cite><a href="https://w3id.org/ro/">Wf4Ever Research Object Model</a></cite> and the <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1109/escience.2014.47"><a href="http://www.ifs.tuwien.ac.at/%7Emayer/publications/pdf/may_escience14.pdf">Ontologies for Describing the Context of Scientific Experiment Processes</a></span> <a href="#ref-13" class="reference">[13]</a> with the <cite><a href="http://www.timbusproject.net/portal/publications/ontologies/">TIMBUS Context Model</a></cite> to compliment the Research Objects model. 
From a more generic perspective, there exist the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/TR/prov-o/">PROV Ontology</a> <a href="#ref-14" class="reference">[14]</a>, the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://www.opmw.org/model/OPMW/">OPMW-PROV Ontology</a> <a href="#ref-15" class="reference">[15]</a>, and the <a property="schema:citation http://purl.org/spar/cito/citesAsAuthority" href="http://rdf-vocabulary.ddialliance.org/discovery.html">DDI-RDF Discovery Vocabulary</a> <a href="#ref-16" class="reference">[16]</a>.
However, these efforts can only cover (parts of) the connection between research and software, which is insufficient for dependency injection.
Such descriptions are however interpretive in that any given tool is subject to having multiple descriptions by different users.
In contrast to the human-driven descriptions, our work both enables and accelerates the generation of machine-driven Linked Data descriptions of software modules, their components, as well as their configurations to be uniformly created.
Consequently, this makes it possible to accurately describe and instantiate software experiments that can be reused and compared with unambiguously.</p>

      <p>Much more low-level and exact is the Core Software Ontology (CSO) <a href="#ref-17" class="reference">[17]</a>,
which provides a foundational vocabulary that is designed for extensibility.
This includes the distinctive concepts to describe software as code, software as object to computational hardware, and software as a running computational activity,
but also Interfaces, Classes, Methods, the relationships between them, and workflow information on their invocation.
Its extension, the Core Ontology of Software Components (COSC), moves closer to the topic of this article by describing interfaces and protocols of components.
Similar in scope is the Software Engineering Ontology Network (SEON) <a href="#ref-18" class="reference">[18]</a>, which consolidates multiple ontologies for the Software Engineering field.
It includes a higher Core and Foundational layer, as well as multiple domain-specific ontologies.
Of particular interest is their Software Ontology (SwO) that captures the different artifacts in software.
In general, both ontologies (or suites) view software from a <q>network of communicating concepts</q> perspective.
This allows for exhaustive descriptions of complex software systems, but is not suited for describing class instances or aspects of modular programming (e.g., package dependencies).</p>

      <h3 id="dependency-injection-frameworks">Dependency injection frameworks</h3>
      <p>The large spectrum of existing dependency injection frameworks indicates a high demand for such systems.
Dependency injection considers every software component as independent:
a single component is only aware about how these dependencies can be used,
but not about their whereabouts or how they were created.
The absence of internal dependencies simplifies testing separate components,
because their dependencies can be easily mocked.
Also, since there is no internal knowledge on a dependency’s origin,
it is much easier to change the actual implementation and how the dependency fulfills the role of its interface.</p>

      <p>Dependency injection frameworks facilitate in the creation of objects
and provide them to the classes that require them.
Hence, they provide the means to define how all the dependencies are linked together,
allowing developers to “outsource” the actual linking.
Java likely contains the largest collection of dependency injection frameworks.
Much of this stems from the strict typing,
which makes it difficult to create mock objects when required for testing
if the dependencies are nested in the implementation.</p>

      <p>One of the biggest Java frameworks is <a href="https://spring.io/">Spring</a>,
which amongst many things, also provides dependency injection.
That is one of its advantages though:
many projects already use Spring for other reasons,
reducing the jump required to add the dependency injection framework.
It supports two ways to do the injection.
The first one is through an external XML configuration file
which defines all the classes and how they are linked together.
The other one is with annotations in the actual code
that define how the interlinking of classes should work.
Google’s <a href="https://github.com/google/guice">Guice</a> is a more lightweight alternative to Spring;
<a href="https://github.com/google/dagger">Dagger</a> was created to be even more lightweight than Guice.</p>

      <p>In JavaScript, 
dependency injection frameworks tend to be less common because of its flexible nature.
Still, multiple frameworks are available, such as <a href="https://github.com/young-steveo/bottlejs">BottleJS</a>, <a href="https://github.com/cujojs/wire">Wire</a>, and <a href="https://github.com/jaredhanson/electrolyte">Electrolyte</a>, all backed by rather small communities.
One of the biggest ones, <a href="https://github.com/inversify/InversifyJS">InversifyJS</a>,
uses annotations similar to Java frameworks to define possible injections.
Unlike standard JavaScript,
it requires you to define interfaces and types,
thereby allowing it to make use of this extra information to correctly handle the linking.
Like Guice, it also has a bindings file to link classes to interfaces.</p>

      <p>Components.js differs from most of the aforementioned frameworks
by having the dependency injection metadata external to the code in RDF files,
both for describing what the classes look like, and how they should be linked together.
This provides the additional semantic benefits mentioned in this paper,
such as identification, dereferencing, and discoverability.</p>

    </section>

    <section id="semantic-dependency-injection">
      <h2>A Semantic Dependency Injection framework</h2>
      <p>This section introduces the dependency injection framework <a href="https://github.com/LinkedSoftwareDependencies/Components.js" class="mandatory" data-link-text="https:/​/​github.com/​LinkedSoftwareDependencies/​Components.js">Components.js</a>.
It can instantiate JavaScript components based on a declarative configuration.
These are semantic by default (i.e., described in RDF using a set of vocabularies), but can also be non-semantic (i.e., using direct references to a JavaScript classes).</p>

      <p>In this respect, Components.js distinguishes between three main concepts:</p>

      <ul>
        <li>
          <p><strong>Module</strong>: a software package containing zero or more components. This is equivalent to a Node module or npm package.</p>
        </li>
        <li>
          <p><strong>Component</strong>: a class that can be instantiated by creating a new instance of that type with zero or more parameter values. Parameters are defined by the class and its superclasses.</p>
        </li>
        <li>
          <p><strong>Component Configuration</strong>: a semantic representation of an instantiation of a component into an instance based on parameters.</p>
        </li>
      </ul>

      <p>All concepts are described in the programming language independent <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components ontology (OO)</em></a> <a href="#ref-8" class="reference">[8]</a>.
In the following, we first explain how to describe modules and components using this ontology.
Then, we introduce an additional <em>Object Mapping ontology</em> to describe parameter order in constructors.
Finally, we explain how component configuration files are created, which describe the application wiring, 
and how the framework can instantiate this file to compose a working application.</p>

      <h3 id="describing-components">Describing modules and components</h3>

      <p>The Object-Oriented Components ontology reuses Fowler’s definition of a <a property="schema:citation http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a href="#ref-7" class="reference">[7]</a> as a “glob” of software, which 
provides operations that can be used by other components.
The instantiation of such components requires certain parameters,
analog to constructor arguments in object-oriented programming.
This is interpreted in the broad sense: only <em>classes</em>, <em>objects</em> and <em>constructor parameters</em> are considered.
An overview is given in <a href="#voc-oo-diagram">Fig. 1</a>.</p>

      <figure id="voc-oo-diagram">
<img src="voc-oo-diagram.svg" alt="[Object-Oriented Components ontology diagram]" />
<figcaption>
          <p><span class="label">Fig. 1:</span> Classes and properties in the <a href="https://linkedsoftwaredependencies.org/vocabularies/object-oriented#" class="mandatory" data-link-text="https:/​/​linkedsoftwaredependencies.org/​vocabularies/​object-​oriented#"><em>Object-Oriented Components</em> ontology</a>,
with as prefix <code>oo</code>.</p>
        </figcaption>
</figure>

      <p><a href="#module">Listing 1</a> illustrates the basic definition of a module <code>MyModule</code>, which is indicated by the type <code>oo:Module</code>.
Note that we added a prefix <code>ex</code> to shorten the URIs.
Additional metadata is added with the <a href="https://github.com/ewilderj/doap/wiki">Description of a Project (DOAP) vocabulary</a>, e.g., <code>doap:name</code>.</p>

      <figure id="module" class="listing">
<pre><code>PREFIX oo: &lt;https://linkedsoftwaredependencies.org/vocabularies/object-oriented#&gt;
PREFIX om: &lt;https://linkedsoftwaredependencies.org/vocabularies/object-mapping#&gt;
PREFIX doap: &lt;http://usefulinc.com/ns/doap#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX ex: &lt;http://example.org&gt;

ex:MyModule a oo:Module;
            doap:name &quot;my-module&quot;.
</code></pre>
<figcaption>
          <p><span class="label">Listing 1:</span> A description of a module <code>ex:MyModule</code>.</p>
        </figcaption>
</figure>

      <p>A module is considered a collection of components.
Within object-oriented languages, this can correspond to for example a software library or an application.
A component is typed as <code>oo:Component</code>, which is a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct the component can therefore be defined as an <code>rdfs:Property</code> on a component.
For instance,
a software module representing a parser
can be described as
<code>ldfs:Datasource:Hdt a oo:Class.</code>,
and a concrete instance is
<code>:myHdtDatasource a ldfs:Datasource:Hdt</code>.</p>

      <p><a href="#component">Listing 2</a> extends <code>MyModule</code> with a component <code>ex:MyModule/MyComponent</code> by adding an <code>oo:component</code> predicate.
The type <code>oo:Class</code> is one of the several defined subclasses of <code>oo:Component</code>,
which indicates that it is instantiatable based on parameters.
Each component can refer to its path within a module using the <code>oo:componentPath</code> predicate,
which can for instance be the package name in npm.
The resulting description can be included in the module
(e.g., as a JSON-LD file),
or can be created and referred to externally.
Afterwards, it can be reused by multiple dependents.</p>

      <figure id="component" class="listing">
<pre><code>ex:MyModule a oo:Module;
  doap:name &quot;my-module&quot;;
  oo:component ex:MyModule/MyComponent.

ex:MyModule/MyComponent a oo:Class;
  oo:componentPath &quot;MyComponent&quot;;
  oo:parameter ex:MyModule/MyComponent#name;
  oo:constructorArguments ( ex:MyModule/MyComponent#name ).

ex:MyModule/MyComponent#name a oo:Parameter;
  rdfs:comment &quot;A name&quot;;
  rdfs:range &quot;xsd:string&quot;;
  oo:uniqueValue true.</code></pre>
<figcaption>
          <p><span class="label">Listing 2:</span> The component <code>ex:MyModule/MyComponent</code> is described as part of the module <code>ex:MyModule</code>.</p>
        </figcaption>
</figure>

      <p>The parameters that are used to instantiate an <code>oo:Class</code> are of type <code>oo:Parameter</code>.
An <code>oo:Parameter</code> is a <em>subclass</em> of <code>rdfs:Property</code>, which simplifies its usage as an RDF property.
<code>oo:defaultValue</code> allows parameters to have a default value when no other values have been provided:
upon instantiation (<a href="#instantiating">Subsection 3.3</a>),
a closed world will be assumed.
The <code>oo:uniqueValue</code> predicate is a flag that can be set to indicate whether or not the parameter can only have a single value.</p>

      <p><a href="#module-ldf">Listing 3</a> shows a simplified example of the Linked Data Fragments (LDF) server npm module.
It exposes several components such as an HDT and SPARQL datasource and a TPF server,
each of which can take multiple parameters.
These are provided with a unique identifier and definition,
such that the software configuration can receive a semantic interpretation.</p>

      <p>Although the examples in this article are presented in Turtle syntax, Components.js encourages the use of JSON-LD for compatibility with JSON and the use of shortcuts.
A general context is defined for the Object-Oriented Components ontology, which is available at <a href="https://linkedsoftwaredependencies.org/contexts/components.jsonld">https:/​/​linkedsoftwaredependencies.org/contexts/components.jsonld</a>.
The dereferencaable URI of your module is defined by <code>@id</code>, and <code>requireName</code> refers to the package (as defined in npm’s package.json file).</p>

      <figure id="module-ldf" class="listing">
<pre><code>PREFIX oo: &lt;https://linkedsoftwaredependencies.org/vocabularies/object-oriented#&gt;
PREFIX rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;
PREFIX ldfs: &lt;https://linkedsoftwaredependencies.org/bundles/npm/ldf-server/&gt;

&lt;https://linkedsoftwaredependencies.org/bundles/npm/ldf-server/2.2.2&gt;
  a oo:Module;
  oo:component ldfs:Server:Qpf, ldfs:Datasource:Hdt, ldfs:Datasource:Sparql.
ldfs:Server:Tpf a oo:Class;
  oo:parameter ldfs:datasource, ldfs:port.
ldfs:Datasource a oo:AbstractClass;
  oo:parameter ldfs:Datasource:title.
ldfs:Datasource:Hdt a oo:Class;
  rdfs:subClassOf ldfs:Datasource;
  oo:parameter ldfs:Datasource:Hdt:file.
ldfs:Datasource:Sparql a oo:Class;
  rdfs:subClassOf ldfs:Datasource;
  oo:parameter ldfs:Datasource:Sparql:endpoint.

ldfs:datasource                 a oo:Parameter; rdfs:range ldfs:Datasource.
ldfs:port                       a oo:Parameter; rdfs:range xsd:integer.
ldfs:Datasource:title           a oo:Parameter; rdfs:range xsd:string.
ldfs:Datasource:Hdt:file        a oo:Parameter; rdfs:range ldfs:HdtFile.
ldfs:Datasource:Sparql:endpoint a oo:Parameter; rdfs:range ldfs:SparqlEndpoint.
</code></pre>
<figcaption>
          <p><span class="label">Listing 3:</span> The LDF server module contains, among others, an HDT and SPARQL-based datasource component, which both extend from the abstract datasource component.
The HDT and SPARQL datasource are a classes, which both inherit the title parameter from the abstract datasource.
The HDT datasource takes an HDT file as parameter.
The SPARQL datasource takes a SPARQL endpoint IRI as parameter.</p>
        </figcaption>
</figure>

      <h3 id="describing-object-mappings">Describing object mappings</h3>
      <p>The constructor injection described above works out of the box
with single-argument constructors that accept a map,
as is quite common in JavaScript.
Components.js then creates a map with key/value pairs
with the property IRIs and corresponding objects
of all triples with the instance as subject.
This map is then passed to the constructor,
which reads its settings from the map.
Depending on a flag,
the keys and values are either full IRIs
or abbreviated JSON-LD strings.</p>

      <p>New libraries that use Components.js
can be designed for such single-parameter constructors.
For all other constructor types,
a mapping mechanism is needed
between the RDF properties
and the concrete parameter order of the constructor.
To this end, we introduce the <a href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping"><em>Object Mapping ontology</em></a>.
<a href="#voc-om-diagram">Fig. 2</a> shows an overview of all its classes and predicates.</p>

      <figure id="voc-om-diagram">
<img src="voc-om-diagram.svg" alt="[Object Mapping ontology diagram]" />
<figcaption>
          <p><span class="label">Fig. 2:</span> Overview of the classes and properties in the <em>Object Mapping</em> ontology, with as prefix <a href="https://linkedsoftwaredependencies.org/vocabularies/object-mapping#" class="mandatory" data-link-text="https:/​/​linkedsoftwaredependencies.org/​vocabularies/​object-​mapping#"><code>om</code></a>.</p>
        </figcaption>
</figure>

      <p>The ontology introduces the <em>object mapping</em> and the <em>array mapping</em>.
An object map can have several <em>object mapping entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array mapping entries</em>, where each entry only has a value.
Together, they can express all ways
in which the flat object from the RDF description
maps to an ordered list of simple or complex constructor parameters.</p>

      <p><a href="#module-ldf-mapped">Listing 4</a> shows the mapping of the LDF component parameters to the constructor implementation.
This description complements the component definitions from <a href="#module-ldf">Listing 3</a>
as it provides an implementation view on the component constructors.
Like the component definitions,
a mapping is only necessary once per module
and can be reused across dependents.</p>

      <figure id="module-ldf-mapped" class="listing">
<pre><code>ldfs:Server:Tpf oo:constructorArguments ([ om:field
  [ om:fieldName &quot;datasources&quot;; om:fieldValue
    [ om:fieldName ldfs:Datasource:title, om:fieldValue rdf:object ] ],
  [ om:fieldName &quot;port&quot;; om:fieldValue: ldfs:port ].
]).
ldfs:Datasource:Hdt oo:constructorArguments ([ om:field
  [ om:fieldName &quot;title&quot;; om:fieldValue: ldfs:Datasource:title ],
  [ om:fieldName &quot;file&quot;;  om:fieldValue: ldfs:Datasource:Hdt:file ].
]).
ldfs:Datasource:Sparql oo:constructorArguments ([ om:field
  [ om:fieldName &quot;title&quot;;    om:fieldValue: ldfs:Datasource:title ],
  [ om:fieldName &quot;endpoint&quot;; om:fieldValue: ldfs:Datasource:Sparql:endpoint ].
]).
</code></pre>
<figcaption>
          <p><span class="label">Listing 4:</span> The HDT and SPARQL-based datasource constructors both take a custom object as argument for the constructor.
The entries of this object are mapped from the parameter values using this mapping.
The TPF server constructor similarly requires a custom object,
where the <code>datasources</code> entry points to an object that is a mapping from titles to datasources.</p>
        </figcaption>
</figure>

      <h3 id="instantiating">Describing and instantiating a component configuration</h3>

      <p>Once modules and components are described, 
a component configuration can wire a JavaScript application by declaring specific instances.
An instance of the module from <a href="#component">Listing 2</a>, with the parameter <code>ex:MyModule/MyComponent#name</code> set to <q>John</q>, is given in <a href="#configuration">Listing 5</a>.
The type of our instance <code>ex:myInstance</code> is simply the component that must be instantiated, in this case <code>ex:MyModule/MyComponent</code>.
All instantiations of <code>oo:Class</code> instances are also of type <code>oo:Instance</code>.
The parameters that were defined by the component, can now be used as keys in the configuration file.</p>

      <figure id="configuration" class="listing">
<pre><code>PREFIX ex: &lt;http://mymodule.org/&gt;

ex:myInstance a ex:MyModule/MyComponent;
  ex:MyModule/MyComponent#name &quot;John&quot;.
</code></pre>
<figcaption>
          <p><span class="label">Listing 5:</span> A component configuration file that describes the instantiation of <code>ex:MyModule/MyComponent</code> with the parameter  <code>ex:MyModule/MyComponent#name</code> set to <q>John</q>.</p>
        </figcaption>
</figure>

      <p>An <code>oo:Class</code> can also be an <code>oo:AbstractClass</code>, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicated using the <code>rdfs:subClassOf</code> predicate.</p>

      <figure id="components.js" class="listing">
<pre><code>const Loader = require(&#39;componentsjs&#39;).Loader;

const loader = new Loader();
const myServer = await loader.instantiate(&#39;http://example.org/config.ttl#myServer&#39;);
</code></pre>
<figcaption>
          <p><span class="label">Listing 6:</span> First, a new component loader is created
after which the component definitions are registered.
Finally, a declarative component instantiation is supplied by providing the component IRI.</p>
        </figcaption>
</figure>

      <p>The initial steps for using the framework are shown in <a href="#components.js">Listing 6</a>.
First, it provides a <code>Loader</code> class that acts as an assembler.
This <code>Loader</code> provides <em>constructor injection</em>:
it dynamically calls the constructor of the component and passes the configured parameters in a single object argument.
Behind the scenes, a module description is registered, which can be retrieved by automatically scanning npm modules, 
parsing a downloaded RDF document via URL, or reading a raw triple stream.
At the time of writing, the parser accepts RDF documents serialized as either JSON-LD, Turtle, TriG, N-Triples or N-Quads.
Finally,
the <code>Loader</code> instantiates one or more components by invoking a component configuration.
<a href="#config-ldf">Listing 7</a> depicts the configuration file for a <a href="http://linkeddatafragments.org/software/#server">Linked Data Fragments server</a> application,
which is identified by <code>http:/​/​example.org/config.ttl#myServer</code>.</p>

      <figure id="config-ldf" class="listing">
<pre><code>PREFIX : &lt;http://example.org/config.ttl#&gt;
PREFIX ldfs: &lt;https://linkedsoftwaredependencies.org/bundles/npm/ldf-server/&gt;

:myServer a ldfs:Server:Qpf;
  ldfs:datasource :myHdtDatasource, :mySparqlDatasource.
:myHdtDatasource a ldfs:Datasource:Hdt;
  ldfs:Datasource:title &quot;A DBpedia 2016 datasource&quot;;
  ldfs:Datasource:Hdt:file &lt;http://data.org/dbpedia-2016.hdt&gt;.
:mySparqlDatasource a ldfs:Datasource:Sparql;
  ldfs:Datasource:title &quot;A SPARQL-based DBpedia 2016 datasource&quot;;
  ldfs:Datasource:Sparql:endpoint &lt;http://data.org/sparql/dbpedia-2016&gt;.
</code></pre>
<figcaption>
          <p><span class="label">Listing 7:</span> <code>ex:myServer</code> is a TPF server which will be loaded with a HDT and SPARQL-based datasource.</p>
        </figcaption>
</figure>

      <p>Note that, while Linked Data has an open-world assumption, our dependency injector operates in the closed-world environment of OOP.
Hence, we assume that all the necessary constructor arguments are included in the configuration and are available to the loader,
as this is required for features such as default arguments.</p>

    </section>

    <section id="proof-of-concept">
      <h2>Proof of Concept</h2>

      <p>To demonstrate the merits of a semantic Dependency Injection framework for JavaScript,
we present a proof of concept using the Node Package Manager (npm) library.
npm is a large collection of modules with over 600,000 JavaScript libraries,
all with their own features and requirements.
Such package contains the description of the project together with all its versions.
Using the terminology from <a href="#semantic-dependency-injection">Section 3</a>,
a specific version of a npm package is considered a <em>module</em>,
which contains the specific dependencies and a link to the actual implementation.</p>

      <p>npm stores the metadata of every package in a <a href="http://couchdb.apache.org/">CouchDB</a>
<a href="https://registry.npmjs.org/">instance</a>,
which includes the information added by the package developer in the <a href="https://docs.npmjs.com/files/package.json"><code>package.json</code></a> file,
and additional metadata added by the npm publishing process.
An example of a JSON representation of the N3.js npm package can be found at <a href="https://registry.npmjs.org/n3/" class="iri-link">https:/​/​registry.npmjs.org/n3/</a>,
which contains all the general descriptions that apply to all packages in this module,
such as the name, homepage and description.
To uniquely identify software components and,
more importantly, interlink them,
we added a JSON-LD context to the JSON metadata provided by the npm registry, 
and published this RDF in a <a href="https://github.com/LinkedSoftwareDependencies/npm-extraction-server" class="mandatory" data-link-text="https:/​/​github.com/​LinkedSoftwareDependencies/​npm-​extraction-​server">server</a>.
This context is available at <a href="https://linkedsoftwaredependencies.org/contexts/npm.jsonld" class="iri-link">https:/​/​linkedsoftwaredependencies.org/contexts/npm.jsonld</a> and maps most of the npm tags to corresponding RDF predicates,
leaving these tags unchanged in the JSON-LD representation.</p>

      <p>For data fields that could not be mapped by using just the JSON-LD context,
such as concatenating values to create an IRI,
we modified some of the input JSON before exporting it to JSON-LD.
The limitations of context mapping necessitated
some other changes,
the most important one relating to the specific versions of the package.
This can be seen by retrieving <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3" class="iri-link">https:/​/​linkedsoftwaredependencies.org/bundles/npm/n3</a> with an <code>Accept: application/ld+json</code> header.
In this case, the package contains links to its corresponding modules,
providing semantic connections between them.
Additionally, some tags were added to provide identifiers and a link to the original repository.</p>

      <p>Since JSON-LD is an RDF representation, it can easily be converted to other syntaxes,
of which several are supported by our server,
such as Turtle and N-Triples.
These can be retrieved by sending the corresponding <code>Accept</code> headers.
An example of some of the data generated this way can be seen in <a href="#n3.ttl">Listing 8</a>.</p>

      <figure id="n3.ttl" class="listing">
<pre><code>npm:n3 a doap:Project;
  dcterms:abstract &quot;Lightning fast, asynchronous, streaming...&quot;;
  dcterms:subject &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot;;
  spdx:licenseDeclared &lt;https://spdx.org/licenses/MIT.html&gt;;
  doap:release 
    &lt;http://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&gt;;
  doap:bug-database &lt;https://github.com/RubenVerborgh/N3.js/issues&gt;;
  doap:homepage &lt;https://github.com/RubenVerborgh/N3.js#readme&gt;;
  doap:name &quot;n3&quot;;
  owl:sameAs &quot;https://www.npmjs.com/package/n3&quot;;
  foaf:maker users:rubenverborgh.
users:rubenverborgh foaf:name &quot;Ruben Verborgh&quot;.
</code></pre>
<figcaption>
          <p><span class="label">Listing 8:</span> This listing shows a partial representation of <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3" class="iri-link">https:/​/​linkedsoftwaredependencies.org/bundles/npm/n3</a> in the Turtle syntax.
Prefixes omitted for brevity.</p>
        </figcaption>
</figure>

      <p>Continuing with the examples shown above,
a module of version 0.10.0 of the N3 bundle can be found at
<a href="https://registry.npmjs.org/n3/0.10.0" class="iri-link">https:/​/​registry.npmjs.org/n3/0.10.0</a>,
while the IRI in our namespace is <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0" class="iri-link">https:/​/​linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0</a>.
Similarly, many of the tags are mapped by the context,
while other tags had to be modified to provide more relevant triples.
An example of some of the data generated for this module can be seen in <a href="#n3-0.10.0.ttl">Listing 9</a>.</p>

      <figure id="n3-0.10.0.ttl" class="listing">
<pre><code>&lt;https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&gt; 
  doap:revision &quot;0.10.0&quot;;
  foaf:maker users:rubenverborgh;
  npm:devDependency 
    &lt;https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1&gt;;
  npm:nodeVersion 
    &lt;https://linkedsoftwaredependencies.org/engines/node/6.7.0&gt;.</code></pre>
<figcaption>
          <p><span class="label">Listing 9:</span> This listing shows a partial representation of <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0" class="iri-link">https:/​/​linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0</a> in the Turtle syntax.
Prefixes omitted for brevity.</p>
        </figcaption>
</figure>

      <p>An important part of an npm package description are the dependencies
and their semantic versions.
For example, N3 0.10.0 has a dependency on <code>async ^2.0.1</code>.
<code>^2.0.1</code> is a semantic version and corresponds to any version number
of async that has a major version of <code>2</code>.
As can be seen in the JSON-LD,
this async dependency is converted to
<a href="https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1" class="iri-link">https:/​/​linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1</a>,
with <code>%5E</code> being the URL-encoded character <code>^</code>.
If accessed, the server detects the highest matching version number
and redirects to that module.
Additionally, the body of the redirect contains the relevant metadata describing this,
which in this case results in the following triple (prefixed for clarity):</p>

      <p><code>
async:\%5E2.0.1 npm:maxSatisfying async:2.4.0.
</code></p>

      <p>Additionally, to properly describe which modules are being used on a machine,
we created a <a href="https://github.com/LinkedSoftwareDependencies/node-dependency-parser" class="mandatory" data-link-text="https:/​/​github.com/​LinkedSoftwareDependencies/​node-​dependency-​parser">tool</a>
that outputs the actual dependencies
used by a specific package installation in RDF.
This way the exact installation that was used can be described,
without having to rely on the interpretation of semantic versions which can change over time.</p>

      <p>The semantic description of software metadata provides a useful platform for simplifying tasks that require a lot manual work,
such as discovering license incompatibilities between projects, which are now possible using a <a href="https://query.linkedsoftwaredependencies.org/#query=SELECT%20*%20WHERE%20%7B%0A%20%20%3Fbundle%20spdx%3AlicenseDeclared%20%3Chttps%3A%2F%2Fspdx.org%2Flicenses%2FGPL-3.0.html%3E.%0A%20%20%3Fbundle%20npm%3Adependency%20%3Fdependency.%0A%20%20%3Fdependency%20spdx%3AlicenseDeclared%20%3Chttps%3A%2F%2Fspdx.org%2Flicenses%2FGPL-2.0.html%3E.%0A%7D">SPARQL query</a>.
All 600,000 npm packages produced 300,000,000+ triples,
which we publish through a <span property="schema:citation http://purl.org/spar/cito/cites" resource="https://dx.doi.org/10.1007/978-3-319-11964-9_12"><a href="http://linkeddatafragments.org/publications/iswc2014.pdf">Triple Pattern Fragments</a></span> <a href="#ref-19" class="reference">[19]</a> interface.
These are located at <a href="https://linkedsoftwaredependencies.org/" class="mandatory" data-link-text="https:/​/​linkedsoftwaredependencies.org/​">https:/​/​linkedsoftwaredependencies.org</a>, together with subject pages for each bundle, module and user.
The triples are collected and republished daily to stay up-to-date with the available information on npm.</p>

      <p>Queries are executed using a <a href="https://query.linkedsoftwaredependencies.org">Triple Pattern Fragments browser client</a>, which can provide insights that <a property="schema:citation http://purl.org/spar/cito/citesForInformation" href="https://www.w3.org/History/1989/proposal.html">the Web was intended to give</a> <a href="#ref-20" class="reference">[20]</a>.
Examples are given in <a href="#query-used">Listing 10</a> and <a href="#query-who">Listing 11</a>, which answer the questions <q><a href="https://query.linkedsoftwaredependencies.org/#query=SELECT%20DISTINCT%20%3Fproject%20%3FprojectName%20%3Fdescription%20WHERE%20%7B%0A%20%20%3Chttps%3A%2F%2Flinkedsoftwaredependencies.org%2Fbundles%2Fnpm%2Fn3%3E%20doap%3Arelease%20%3Fversion.%0A%20%20%3Fdependingversion%20npm%3Adependency%20%3Fversion.%0A%20%20%3Fproject%20doap%3Arelease%20%3Fdependingversion.%0A%20%20%3Fproject%20doap%3Aname%20%3FprojectName.%0A%20%20%3Fproject%20dc%3Aabstract%20%3Fdescription.%0A%7D">Where is this module used?</a></q> and <q><a href="https://query.linkedsoftwaredependencies.org/#query=SELECT%20*%20WHERE%20%7B%0A%20%20%3Chttps%3A%2F%2Flinkedsoftwaredependencies.org%2Fbundles%2Fnpm%2Fn3%3E%20doap%3Amaintainer%20%3Fauthor.%0A%20%20%3Fauthor%20foaf%3Aname%20%3Fname.%0A%20%20%3Fauthor%20foaf%3Ambox%20%3Fmail.%0A%7D">Who wrote this code?</a></q>.</p>

      <figure id="query-used" class="listing">
<pre><code>SELECT DISTINCT ?project ?projectName ?description WHERE {
  &lt;https://linkedsoftwaredependencies.org/bundles/npm/n3&gt; doap:release ?version.
  ?dependingversion npm:dependency ?version.
  ?project doap:release ?dependingversion.
  ?project doap:name ?projectName.
  ?project dc:abstract ?description.
}</code></pre>
<figcaption>
          <p><span class="label">Listing 10:</span> SPARQL query to discover all dependencies of a package.</p>
        </figcaption>
</figure>

      <figure id="query-who" class="listing">
<pre><code>SELECT * WHERE {
  &lt;https://linkedsoftwaredependencies.org/bundles/npm/n3&gt; doap:maintainer ?iauthor.
  ?author owl:sameAs ?iauthor.
  ?author foaf:name ?name.
  ?author foaf:mbox ?mail.
}</code></pre>
<figcaption>
          <p><span class="label">Listing 11:</span> SPARQL query to discover the author of a package.</p>
        </figcaption>
</figure>

      <p>As a complete example, the documentation of Components.js has been made self-instantiatable using its own framework and is available at <a href="http://componentsjs.readthedocs.io/en/latest/example/">http:/​/​componentsjs.readthedocs.io/en/latest/example/</a>.</p>

    </section>

    <section id="discussion">
      <h2>Discussion</h2>

      <p>The scientific process preaches <em>standing on the shoulders of giants</em>.
This entails continuing existing work to derive new work, but
also, enabling others to build upon our work.
An essential aspect of this process is <em>reproducibility</em> of experimental results.
This concept also applies to Web research,
but the Web itself, is also an ideal platform to improve the scientific process.</p>

      <p>Unfortunately,
a large number of computer science articles report software only by name or version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has obtained the reported results.
Therefore, potential users do not necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any such aspects.</p>

      <p>Components.js deliberately adds semantics and Linked Data to dependency injection in order to accurately refer to exact software configurations used in an article, 
and automatically instantiating that configuration,
thereby improving replication of experimental software.
Furthermore, 
it facilitates independently replacing and evaluating components
and publishing these configurations in turn.</p>

      <p><a property="schema:citation http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a href="#ref-21" class="reference">[21]</a> explains that
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment,
all of the involved artifacts and actors,
and the processing of the retrieved data.
In essence, this entails the complete chain of provenance illustrated in <a href="#description-diagram">Fig. 3</a>,
that links the research article to the data and the experiment that generates it,
as well as all aspects surrounding that experiment.</p>

      <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
          <p><span class="label">Fig. 3:</span> A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article provides mechanisms
to describe <em>software configurations</em> and <em>software modules</em>.</p>
        </figcaption>
</figure>

      <p>Through this work, we make it easier to build sustainable research platforms,
which helps pave the stairs to the shoulders of giants.
The Linked Data Fragments server, for instance, is a reusable research platform.
The LDF server and client can be compatible with multiple APIs, support multiple features, and use multiple, interchangeable algorithms.
Components.js requires only one “core version” to exist, while many alternative configurations can co-exist.
Support for different APIs and algorithms are simply pluggable components that are referred to within a configuration.
Since components and configurations are identified by an IRI,
they can exist anywhere on the Web.
Based on an IRI, the injection framework can therefore instantiate software,
and wire its dependent components together.
The power of the Web is thereby leveraged, simplifying the replication of existing experiments
and the creation of new ones.</p>

    </section>

    <section id="conclusion">
      <h2>Conclusion</h2>

      <p>In this article, we introduced Components.js, a dependency injection framework that
(i) <em>interprets</em> semantically described software components and their configuration, and thereby
(ii) automatically <em>instantiates</em> experimental JavaScript Applications.
Semantic Dependency Injection brings the Linked Data merits to empirical software engineering,
enabling experimental software setups to be more transparent, flexible, and <em>unambiguously</em> citable.
This enables joint discovery of experimental software and research articles by means of querying.
Furthermore, experiment reporting can be extended with an IRI to the software configuration.
The use of semantic configuration files can also facilitate more advanced static program analysis.</p>

      <p>In future work, we aim to make the creation of semantic component files more developer-friendly.
A tool can automatically parse source code
and derive the appropriate semantic description on how components can be instantiated using which parameters.
Additionally, these semantic component definition files provide an interesting platform for validating software dependency relations.
Reasoning could for instance be done on parameter restrictions to check whether
or not different bundle versions will break certain component invocations.</p>

    </section>

    <footer>
<section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd resource="#shull2007guide" typeof="schema:Book">Shull, F., Singer, J., Sjøberg, D.I.K.: Guide to advanced empirical software engineering. Springer (2007).</dd>
  <dt id="ref-2">[2]</dt>
  <dd resource="https://dx.doi.org/10.1109/FOSE.2007.30" typeof="schema:Article">Sjoberg, D.I.K., Dyba, T., Jorgensen, M.: The Future of Empirical Methods in Software Engineering Research. In: Future of Software Engineering. pp. 358–378 (2007).</dd>
  <dt id="ref-3">[3]</dt>
  <dd resource="#monperrus2015introduction" typeof="schema:CreativeWork">Monperrus, M.: Introduction to Empirical Software Engineering (2015).</dd>
  <dt id="ref-4">[4]</dt>
  <dd resource="#jedlitschka2008reporting" typeof="schema:Chapter">Jedlitschka, A., Ciolkowski, M., Pfahl, D.: Reporting experiments in software engineering. In: Guide to advanced empirical software engineering. pp. 201–228. Springer (2008).</dd>
  <dt id="ref-5">[5]</dt>
  <dd resource="#easterbrook2008selecting" typeof="schema:Chapter">Easterbrook, S., Singer, J., Storey, M.-A., Damian, D.: Selecting empirical methods for software engineering research. In: Guide to advanced empirical software engineering. pp. 285–311. Springer (2008).</dd>
  <dt id="ref-6">[6]</dt>
  <dd resource="#shull2008role" typeof="schema:Article">Shull, F.J., Carver, J.C., Vegas, S., Juristo, N.: The role of replications in empirical software engineering. Empirical software engineering. 13, 211–218 (2008).</dd>
  <dt id="ref-7">[7]</dt>
  <dd resource="https://martinfowler.com/articles/injection.html" typeof="schema:CreativeWork">Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern. <a href="https://martinfowler.com/articles/injection.html">https:/​/​martinfowler.com/articles/injection.html</a> (2004).</dd>
  <dt id="ref-8">[8]</dt>
  <dd resource="https://linkedsoftwaredependencies.org/articles/describing-experiments/" typeof="schema:Article">Van Herwegen, J., Taelman, R., Capadisli, S., Verborgh, R.: Describing configurations of software experiments as Linked Data. In: Proceedings of the 1st SemSci Workshop (2017).</dd>
  <dt id="ref-9">[9]</dt>
  <dd resource="#malone2014software" typeof="schema:Article">Malone, J., Brown, A., Lister, A.L., Ison, J., Hull, D., Parkinson, H., Stevens, R.: The Software Ontology (SWO): a resource for reproducibility in biomedical data analysis, curation and digital preservation. Journal of biomedical semantics. 5, 25 (2014).</dd>
  <dt id="ref-10">[10]</dt>
  <dd resource="http://usefulinc.com/ns/doap" typeof="schema:CreativeWork">Wilder-James, E.: Description of a Project. <a href="http://usefulinc.com/ns/doap">http:/​/​usefulinc.com/ns/doap</a> (2017).</dd>
  <dt id="ref-11">[11]</dt>
  <dd resource="https://dx.doi.org/10.1145/2814864.2814882" typeof="schema:Article">Rautenberg, S., Ermilov, I., Marx, E., Auer, S., Ngonga Ngomo, A.-C.: LODFlow: A Workflow Management System for Linked Data Processing. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 137–144. ACM, New York, NY, USA (2015).</dd>
  <dt id="ref-12">[12]</dt>
  <dd resource="https://dx.doi.org/10.1016/j.websem.2015.01.003" typeof="schema:Article">Belhajjame, K., Zhao, J., Garijo, D., Gamble, M., Hettne, K., Palma, R., Mina, E., Corcho, O., Gómez-Pérez, J.M., Bechhofer, S., Klyne, G., Goble, C.: Using a suite of ontologies for preserving workflow-centric research objects. Web Semantics: Science,  Services and Agents on the World Wide Web. 32, 16–42 (2015).</dd>
  <dt id="ref-13">[13]</dt>
  <dd resource="https://dx.doi.org/10.1109/escience.2014.47" typeof="schema:Article">Mayer, R., Miksa, T., Rauber, A.: Ontologies for Describing the Context of Scientific Experiment Processes. In: 10th International Conference on e-Science. IEEE (2014).</dd>
  <dt id="ref-14">[14]</dt>
  <dd resource="https://www.w3.org/TR/prov-o/" typeof="schema:CreativeWork">Lebo, T., Sahoo, S., McGuinness, D.: Prov-O: The PROV Ontology. W3C, <a href="https://www.w3.org/TR/prov-o/">https:/​/​www.w3.org/TR/prov-o/</a> (2013).</dd>
  <dt id="ref-15">[15]</dt>
  <dd resource="http://www.opmw.org/model/OPMW/" typeof="schema:CreativeWork">Garijo, D., Gil, Y.: OPMW-PROV Ontology. <a href="http://www.opmw.org/model/OPMW/">http:/​/​www.opmw.org/model/OPMW/</a> (2014).</dd>
  <dt id="ref-16">[16]</dt>
  <dd resource="http://rdf-vocabulary.ddialliance.org/discovery.html" typeof="schema:CreativeWork">Bosch, T., Cyganiak, R., Wackerow, J., Zapilko, B.: DDI-RDF Discovery Vocabulary. <a href="http://rdf-vocabulary.ddialliance.org/discovery.html">http:/​/​rdf-vocabulary.ddialliance.org/discovery.html</a> (2015).</dd>
  <dt id="ref-17">[17]</dt>
  <dd resource="#oberle2009ontology" typeof="schema:Chapter">Oberle, D., Grimm, S., Staab, S.: An ontology for software. In: Handbook on ontologies. pp. 383–402. Springer (2009).</dd>
  <dt id="ref-18">[18]</dt>
  <dd resource="#ruy2016seon" typeof="schema:Article">Ruy, F.B., de Almeida Falbo, R., Barcellos, M.P., Costa, S.D., Guizzardi, G.: SEON: A software engineering ontology network. In: European Knowledge Acquisition Workshop. pp. 527–542. Springer (2016).</dd>
  <dt id="ref-19">[19]</dt>
  <dd resource="https://dx.doi.org/10.1007/978-3-319-11964-9_12" typeof="schema:Article">Verborgh, R., Hartig, O., De Meester, B., Haesendonck, G., De Vocht, L., Vander Sande, M., Cyganiak, R., Colpaert, P., Mannens, E., Van de Walle, R.: Querying Datasets on the Web with High Availability. In: Proceedings of the 13th International Semantic Web Conference. pp. 180–196. Springer (2014).</dd>
  <dt id="ref-20">[20]</dt>
  <dd resource="https://www.w3.org/History/1989/proposal.html" typeof="schema:CreativeWork">Berners-Lee, T.: Information Management: A Proposal. <a href="https://www.w3.org/History/1989/proposal.html">https:/​/​www.w3.org/History/1989/proposal.html</a> (1989).</dd>
  <dt id="ref-21">[21]</dt>
  <dd resource="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf" typeof="schema:CreativeWork">Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University, <a href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">http:/​/​www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf</a> (1995).</dd>
</dl>
</section>
<section id="document-interactions">
  <h2>Interactions</h2>
  <div></div>
  <p class="instructions">
    In order to add comments or annotations,
    please use the button on the top right of this page.
  </p>
</section>
</footer>
  </article>
</main>



</body>
</html>
