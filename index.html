<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Reproduceable software experiments through semantic configurations</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css">
  <link rel="stylesheet" media="print"  href="styles/print.css">
</head>
<body>
  <header>
  <h1 id="reproduceable-software-experiments-through-semanticconfigurations">Reproduceable software experiments through semantic configurations</h1>

  <ul id="authors">
    <li><a href="http://www.rubensworks.net/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://joachim-loves-hamburgersss.linkedsoftwaredependencies.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://csarven.ca/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://csarven.ca/#i">Sarven Capadisli</a>
<a href="#eisd"><sup>2</sup></a></li>
    <li><a href="https://ruben.verborgh.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>
<a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
    <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The scientific process requires reproducible experiments and findings
to foster trust and accountability.
Within computer science engineering,
reproducing experiments involves setting up
the exact same software with the same benchmarks and test data,
which often requires non-trivial manual work.
<!-- Need         -->
Unfortunately,
many research articles ambiguously refer to software by name only,
leaving out crucial details such as module and dependency version numbers
or the configuration of the individual components.
<!-- Task         -->
To this end, we created vocabularies
for the semantic description of software components and their configuration,
which can be published as Linked Data alongside experimental results.
We implemented a dependency injection framework
to accurately instantiate these described experimental configurations.
<!-- Object       -->
This article discusses the approach and its application,
and explains with a use case
how to publish experiments and their software configurations on the Web.
<!-- Findings     -->
In order to enable semantic interlinking between configurations and modules,
we published the metadata of all 475,000+ JavaScript libraries on npm
as 150,000,000+ RDF triples.
<!-- Conclusion   -->
Through our work,
research articles can refer by URL
to fine-grained, instantiatable descriptions of experimental setups,
completing the provenance chain from
specifications to implementations, dependencies, and configurations
all the way to experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.
<!-- Perspectives -->
Moreover, this work can serve other use cases,
such as general software instantiation outside of experiments,
and reasoning or querying over software configuration metadata.</p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>

    <p>A large number of computer science articles describe experimental software evaluations,
but many of them refer to that software only by name or version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which exact versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has obtained the reported results.
Therefore, potential users cannot necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any such aspects.</p>

    <p>As <a property="http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a class="reference" href="#ref-1">[1]</a> explains,
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment,
all of the involved artefacts and actors,
and the processing of the retrieved data.</p>

    <p>Using <a property="http://purl.org/spar/cito/citesAsAuthority" href="https://www.w3.org/DesignIssues/LinkedData.html">Linked Data</a> <a class="reference" href="#ref-2">[2]</a>
to publish such descriptions provides two immediate benefits:
the experimental setup and parts thereof can be <em>identified by IRIs</em>,
and their details can be retrieved by <em>dereferencing those IRIs</em>.
Therefore, if research articles complement their textual explanation of an experiment
with the IRI of the full setup, reproducibility is strongly facilitated.
Moreover, the IRIs of the entire experiment or its parts
can be reused in other articles or experiments
to unambiguously refer to the same conditions.
<a href="#description-diagram">Fig. 1</a> illustrates how this leads to a chain of provenance
from the research article to the data
and the experiment that generates it,
as well as all aspects surrounding that experiment.</p>

    <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
        <p><span class="label">Fig. 1:</span> A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article focuses on <em>software configurations</em> and <em>software modules</em>.</p>
      </figcaption>
</figure>

    <p>In this article,
we focus on the description of <em>software configurations</em> and <em>software modules</em>,
such that an evaluated software setup
can be referred to unambiguously by an IRI.
We thereby avoid the inherent vagueness
of referring to software by name or version only.
We further facilitate the reproduction of experiments
through a mechanisms that automatically <em>instantiates</em> the software configuration
based on its Linked Data description.
Our contributions are the following:</p>

    <ul>
      <li>the RDF-based description of <strong>software modules</strong>,
applied to the 475,000+ bundles of <a href="https://www.npmjs.com/">npm</a> (Node.js);</li>
      <li>the RDF-based description of <strong>available components</strong> within software modules;</li>
      <li>the RDF-based description of a <strong>precise configuration</strong> of software modules;</li>
      <li>the <strong>automated instantiation</strong> of such a configuration;</li>
      <li>a <strong>use case</strong> explaining the usage of the resulting Linked Data
in scientific articles.</li>
    </ul>

    <p>This article is structured as follows.
In <a href="#related-work">Section 2</a>, we discuss related work.
Next, in <a href="#overview">Section 3</a> we present an overview of the required steps for software experimentations that will be discussed in this paper.
<a href="#describing-modules">Section 4</a> introduces the semantic description of software modules.
Next, <a href="#describing-components">Section 5</a> discusses a semantic description of software components,
followed by the introduction of a dependency injection framework that can instantiate these described components in <a href="#instantiating">Section 6</a>.
In <a href="#use-case">Section 7</a>, we present a use case where we apply software descriptions
to an experimental evaluation.
Finally, we discuss our conclusions and future work in <a href="#conclusion">Section 8</a>.</p>

  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p>In this section, we discuss the related work on the reproducibility of scientific experiments in scholarly articles,
ontologies for describing these experiments, and dependency injection as a design principle in experimental software.</p>

    <h3 id="scholarly-publishing-and-reproducibility">Scholarly publishing and reproducibility</h3>
    <p>In order to better keep track of experiments and minimise information loss at CERN, <a property="http://purl.org/spar/cito/citesForInformation" href="https://www.w3.org/History/1989/proposal.html">Information Management: A Proposal</a> <a class="reference" href="#ref-3">[3]</a>, recommends a system (WWW) to address questions like <q>Where is this module used? Who wrote this code? Which systems depend on this device?</q>. We contend that the vision to link information systems in the domain of scientific experiments and scholarly articles is not fully realised on the Web. Identifiable parts of experiments, workflows, as well as the articles which refer to them, still predominantly require human intervention and interpretation, and thereby leaving deterministic reproducibility an open problem on the Web. Our work focuses on improving the state of <q>black box</q> science in particular to experiments using software from the <cite>node package manager</cite>.</p>

    <p class="todo">We should cite <a property="http://purl.org/spar/cito/cites" href="http://laurensrietveld.nl/pdf/lodlab.pdf">LOD Lab</a> <a class="reference" href="#ref-4">[4]</a>,
as they brought a major new angle to reproducibility within the Semantic Web.
Should also look at their argumentation.</p>

    <h3 id="ontologies-and-vocabularies-for-describing-experiments">Ontologies and vocabularies for describing experiments</h3>
    <p><a property="http://purl.org/spar/cito/cites" href="http://doi.acm.org/10.1145/2814864.2814882">LODFlow</a> <a class="reference" href="#ref-5">[5]</a> proposes the <cite><a href="https://github.com/AKSW/ldwpo">Linked Data Workflow Project Ontology</a></cite> to describe and plan workflows, tool configurations, and reporting.
Tool specifications and their configurations in LODFlow workflows are described declaratively by a human user without a prescribed schema.
Such descriptions are however interpretive in that any given tool is subject to having multiple descriptions by different users.
In contrast to the human-driven descriptions, our work both enables and accelerates the generation of machine-driven Linked Data descriptions of software modules, their components, as well as their configurations to be uniformly created.
Consequently, this makes it possible to accurately describe and instantiate software experiments that can be reused and compared with unambiguously.</p>

    <h3 id="related-work-dependency-injection">Dependency injection</h3>

    <p><a property="http://purl.org/spar/cito/cites" href="http://dx.doi.org/10.1002/smr.257"><em>Separation of concerns</em></a> <a class="reference" href="#ref-6">[6]</a> is a software design principle in which software is
split into separate components, each having their own separate task.
Fowler defines a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-7">[7]</a> as
<q>a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component</q>.
This design principle is especially useful for experimental software,
because it improves the flexibility to, for instance,
compare different implementations of an algorithm
by plugging them into a larger piece of software.</p>

    <p>Programmers traditionally interact with a library of components
by calling its functionality from within their own code.
In that case, the developed software module defines the flow of control.
In contrast, with <a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/bliki/InversionOfControl.html"><em>Inversion of Control</em></a> <a class="reference" href="#ref-8">[8]</a><a class="reference" href="#ref-9">[9]</a>,
an external component framework defines this flow:
programmers write code such that it can be called by the framework.
This concept is also known as the <em>Hollywood Principle</em> <a class="reference" href="#ref-10">[10]</a>:
<q>Don’t call us, we’ll call you</q>.
<a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> <a class="reference" href="#ref-7">[7]</a> is a form of Inversion of Control where components
are injected into other components by an <em>Assembler</em>.
Experimental software benefits from this paradigm,
because it allows different components to be defined and injected independently.</p>

    <p>Dependency injection requires a <em>configuration phase</em>
to describe how components need to be wired together,
and an <em>injection phase</em> to perform the actual instantiation.
Frameworks such as <a href="https://projects.spring.io/spring-framework/">Spring</a>
facilitate configuration by specifying it declaratively in a configuration file.
That way, a specific software configuration can be instantiated
by merely describing it in XML or JSON.
These configuration files, however,
can not always be reused outside the scope of a particular project.
Furthermore, different mechanisms are used
to capture additional information needed for the instantiation,
such as module dependencies and their version numbers.
There is no interoperability between these configuration files,
and they cannot easily be combined into a detailed description
of the exact software used.</p>

    <p>To that end, we introduce RDF-based software dependency configurations
(<a href="#describing-components">Section 5</a>)
that exactly capture the used modules and dependencies
(<a href="#describing-modules">Section 4</a>).
The resulting description can then be published on the Web as Linked Data,
for instance, as part of the description of an experimental evaluation
(<a href="#overview">Section 3</a>).
Furthermore, we implemented a framework
that can instantiate such software descriptions
directly from the Web
(<a href="#instantiating">Section 6</a>).</p>

  </section>

  <section id="overview">
    <h2>Overview of software experiment descriptions</h2>

    <p>The correct description of experimental evaluations has many aspects.
In this article, we focus on those aspects related to the description of software,
of which we provide an overview in <a href="#software-aspects">Subsection 3.1</a>.
We then describe in <a href="#workflow">Subsection 3.2</a> how these aspects fit
into a generic workflow of describing experimental setups.</p>

    <h3 id="software-aspects">Aspects of software-based research</h3>

    <p class="todo">This section will shortly introduce each of the blocks in the diagram.
Ruben V. will write the basis.</p>

    <p class="todo">Mention somewhere here that we will use JSON-LD syntax for the examples in this paper.</p>

    <h4 id="specification">Specification</h4>
    <p class="todo">Write</p>

    <h4 id="module">Module</h4>
    <p class="todo">Write</p>

    <p class="todo">A module consists of <em>components</em></p>

    <h4 id="configuration">Configuration</h4>
    <p class="todo">Write</p>

    <h4 id="experiment">Experiment</h4>
    <p class="todo">Write</p>

    <h4 id="results">Results</h4>
    <p class="todo">Write</p>

    <h4 id="article">Article</h4>
    <p class="todo">Write</p>

    <h3 id="workflow">Workflow to describe experimental setups</h3>

    <p>A possible workflow for describing experimental setups is as follows:</p>

    <ol>
      <li>Design experiment execution and workflow (DIO, OPMW, P-Plan)</li>
      <li>Environment setup</li>
      <li>Retrieve software module and RDFise</li>
      <li>RDFise software configuration</li>
      <li>?</li>
      <li>Create dataset structure (RDF Data Cube, SKOS)</li>
      <li>?</li>
      <li>Run experiment</li>
      <li>Catch and store results data (RDF Data Cube)</li>
      <li>Create visualisation and analysis</li>
    </ol>

    <p>Activities, entities and actors are defined and captured at each workflow step using PROV-O.</p>

  </section>

  <section id="describing-modules">
    <h2>Describing software modules</h2>

    <p>There are several levels of granularity on which software can be described,
going from a high-level package overview to a low-level description of the actual code.
In our descriptions we make use of several of these layers,
depending on the context and the requirements.
Drilling down from the top to the bottom, we have the following layers:</p>

    <ul>
      <li>a <em>bundle</em> is a container. It describes what the software is expected to do. 
 An example of this would be the <em>N3.js</em> library.</li>
      <li>a <em>module</em> is a software package implementing a specific bundle. 
 This is also known as a version of a bundle.
 <em>N3.js 0.10.0</em> is a module.</li>
      <li>a <em>component</em> is a specific part of a module 
 that can be called in a certain way with a certain set of parameters.
 The <em>N3.js 0.10.0 Parser</em> is a component.</li>
    </ul>

    <p>Within this section we will focus on bundles and modules,
while components are described more in-depth in the following sections.</p>

    <h3 id="node-package-manager-npm">Node Package Manager (npm)</h3>
    <p>An example of a large collection of bundles and modules is the npm library.
It contains over 475,000 Node.js libraries,
all with their own features and requirements.
Using our terminology,
an npm package would be a bundle,
while a specific version of such a package would be a module.
The package contains the description of the project together with all its versions,
while a version contains the specific dependencies and a link to the actual implementation.</p>

    <p>All this npm data is stored in a <a href="http://couchdb.apache.org/">CouchDB</a> 
<a href="https://registry.npmjs.org/">instance</a> with one entry per bundle.
This corresponds to the metadata, added by the package developer in a <a href="https://docs.npmjs.com/files/package.json"><code>package.json</code></a> file,
with additional metadata automatically added by the npm publishing process.
To be able to uniquely identify software components and,
more importantly, interlink software components,
we converted the JSON metadata provided by the npm registry to RDF.</p>

    <h3 id="json-ld">JSON-LD</h3>
    <p>Since our input data is JSON,
it made sense to convert to <a href="http://json-ld.org/">JSON-LD</a>,
a format specifically made for adding semantics to JSON.
JSON-LD achieves this by adding a so-called <em>context</em> to the JSON data.
This context describes how the JSON tags should be interpreted.
E.g., having <code>"name": "foaf:name"</code> in your context implies
that all name tags should be interpreted as the predicate <code>foaf:name</code>.
Other JSON-LD keywords can be used to identify if certain values are URIs,
or if an entity has a specific type.
For the data where we could not reach the format using just the JSON-LD context,
such as concatenating values to create a URI,
we modified some of the input JSON before exporting it to JSON-LD.</p>

    <p class="todo">Decrease tags in examples for pages.
Probably also drop either JSON-LD or turtle</p>

    <h3 id="bundles">Bundles</h3>
    <p>A bundle represents the general npm package.
An example of a JSON representation of an npm bundle can be found at <a href="https://registry.npmjs.org/n3/">https://registry.npmjs.org/n3/</a>.
This contains all the general descriptions that apply to all bundles in this module,
such as the name, homepage and description.</p>

    <p>To adapt this JSON to RDF,
we start by adding our context,
<a href="https://linkedsoftwaredependencies.org/contexts/npm">https://linkedsoftwaredependencies.org/contexts/npm</a>,
which already maps many of the npm tags to corresponding RDF predicates.
This allows these tags to stay the same in the JSON-LD representation,
with changes required.
Due to the limitations of context mapping,
some other changes were needed,
with the most important one relating to the specific versions of the bundle.
This can be seen by calling <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3">https://linkedsoftwaredependencies.org/bundles/npm/n3</a> with the <code>"Accept: application/ld+json"</code> header..
There the bundle now contains links to its corresponding modules,
providing semantic links between them.
Additionally, some tags were added to provide identifiers and link to the original repository.</p>

    <p>Since JSON-LD is an RDF representation it can easily be converted to other formats,
of which several are supported by our server,
such as turtle and n-triples.
These can be retrieved by sending the corresponding Accept headers.
An example of some of the data generated this way can be seen in <a href="#n3.ttl">Listing 1</a>.</p>

    <p class="todo">Bit weird to link to the listing at the end, might have to change the story up a bit somehow.</p>

    <figure id="n3.ttl" class="listing">
<pre><code>npm:n3 a doap:Project;
    dcterms:abstract &quot;Lightning fast, asynchronous, streaming...&quot;;
    dcterms:subject &quot;turtle&quot;, &quot;rdf&quot;, &quot;n3&quot;, &quot;streaming&quot;, &quot;asynchronous&quot;;
    spdx:licenseDeclared &lt;https://spdx.org/licenses/MIT.html&gt;;
    doap:release &lt;http://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0&gt;;
    doap:bug-database &lt;https://github.com/RubenVerborgh/N3.js/issues&gt;;
    doap:homepage &lt;https://github.com/RubenVerborgh/N3.js#readme&gt;;
    doap:name &quot;n3&quot;;
    owl:sameAs &quot;https://www.npmjs.com/package/n3&quot;;
    foaf:maker users:rubenverborgh.
users:rubenverborgh foaf:mbox &quot;ruben.verborgh@gmail.com&quot;;
    foaf:name &quot;Ruben Verborgh&quot;.
</code></pre>
<figcaption>
        <p><span class="label">Listing 1:</span> Partial turtle representation of <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3">https://linkedsoftwaredependencies.org/bundles/npm/n3</a>.
Prefix definitions omitted for brevity.</p>
      </figcaption>
</figure>

    <h3 id="modules">Modules</h3>
    <p>A module is a specific version of a package.
Continuing with the examples shown above,
the JSON metadata of version 0.10.0 of the N3 bundle can be found at
<a href="https://registry.npmjs.org/n3/0.10.0">https://registry.npmjs.org/n3/0.10.0</a>,
while the URI in our namespace is <a href="https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0">https://linkedsoftwaredependencies.org/bundles/npm/n3/0.10.0</a>.
Here also, many of the tags are mapped by the context,
while other tags had to be modified to provide more interesting data.</p>

    <p>An important part of an npm package description are the dependencies
and their semantic versions.
E.g., N3 0.10.0 has a dependency on <code>async ^2.0.1</code>.
<code>^2.0.1</code> is a semantic version and corresponds to any version number
of async that starts with a 2.
As can be seen in the JSON-LD,
this async dependency gets converted to
<a href="https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1">https://linkedsoftwaredependencies.org/bundles/npm/async/%5E2.0.1</a>,
with <code>%5E</code> being the url-encoded <code>^</code>.
If accessed, the server detects the highest matching version number
and redirects to that module.
Additionaly, the body of the redirect contains the relevant metadata describing this,
which in this case results in the following triple:</p>

    <p><code>
&lt;https://linkedsoftwaredependencies.org/bundles/npm/async/^2.0.1&gt; &lt;https://linkedsoftwaredependencies.org/vocabularies/npm#maxSatisfying&gt; &lt;https://linkedsoftwaredependencies.org/bundles/npm/async/2.4.0&gt;.
</code></p>

    <p>Another tag where we changed the content is the <em>scripts</em> tag.
Since there is a fixed set of scripts that <a href="https://docs.npmjs.com/misc/scripts">npm supports</a>,
being able to easily query those can be helpful for automated systems.
To that end we converted the actual script tags to specific predicates,
such as <code>&lt;https://linkedsoftwaredependencies.org/scripts/npm/test&gt;</code> for the test script.
These predicates have as object a new URI that links to actual content of that script,
meaning the execution script is found by accessing that URI.</p>

  </section>

  <section id="describing-components">
    <h2>Describing components and their configuration</h2>

    <p>In this section, we introduce the <em>Object-Oriented Components</em> ontology for describing software components and how they can be instantiated.
We provide an example of the application of this vocabulary to object-oriented software components using JavaScript.</p>

    <p class="todo">Be mentally prepared for needing to remove these figures. Idea would be to include them in the ontology, and change our ontology application so it also shows images. (That would be nice actually.)</p>

    <h3 id="object-oriented-components">Object-oriented components</h3>

    <p>Within the <a href="http://linkedsoftwaredependencies.org/vocabularies/object-oriented"><em>Object-Oriented Components ontology</em></a>,
we reuse Fowler’s definition of a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-7">[7]</a> as a “glob” of software.
The purpose of a component is to provide operations that can be used by other components.
The instantiation of a component can require certain parameters,
just like object-oriented programming (OOP) languages allow constructors to have certain arguments.
In this section, we assume OOP in the broad sense of the word, which only requires <em>classes</em>, <em>objects</em> and <em>constructor parameters</em>.
<a href="#voc-oo-diagram">Fig. 2</a> shows an overview of all the classes and predicates in the ontology.</p>

    <figure id="voc-oo-diagram">
<img src="voc-oo-diagram.svg" alt="[Object-Oriented Components ontology diagram]" />
<figcaption>
        <p><span class="label">Fig. 2:</span> Overview of the classes and properties in the <em>object-oriented components</em> ontology.</p>
      </figcaption>
</figure>

    <p>We define a <em>module</em> as a collection of components.
Within OOP languages, this can correspond to for example a software library or an application,
which can contain a multitude of functionalities, i.e., components.</p>

    <p>We define component as a <em>subclass</em> of <code>rdfs:Class</code>.
The parameters to construct a component can therefore be defined as an <code>rdfs:Property</code> on a component.
This class structure enables convenient semantic descriptions of components instantiations,
requiring only the fundamental concepts of RDF classes and properties.</p>

    <p>Several <code>oo:Component</code> subclasses are defined.
An <code>oo:Component</code> can be an <code>oo:Class</code>, which means that it can be instantiated based on parameters.
All instantiations of <code>oo:Class</code> instances are an <code>oo:Instance</code>.
It can also be an <code>oo:Instance</code>, meaning that it can directly be used within other components and needs no further instantiation.
An <code>oo:Class</code> can also be <code>oo:AbstractClass</code>, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicated using the <code>rdfs:subClassOf</code> predicate.</p>

    <p>The parameters that are used to instantiate an <code>oo:Class</code> to an <code>oo:Instance</code> are of type <code>oo:Parameter</code>.
An <code>oo:Parameter</code> is a <em>subclass</em> of <code>rdfs:Property</code>, which simplifies its usage as an RDF property.
<code>oo:defaultValue</code> allows parameters to have a default value when no other values have been provided.
The <code>oo:uniqueValue</code> predicate is a flag that can be set to indicate whether or not the parameter can only have a single value.</p>

    <p><a href="#module-n3">Listing 2</a> shows an example of the N3.js npm module using the components ontology.
It exposes several components such as <em>Parser</em> and <em>Lexer</em>.
Each of these components can take several different parameters.
<a href="#config-n3">Listing 3</a> illustrates how instances can be created of these component types.</p>

    <figure id="module-n3" class="listing">
<pre><code>ex:n3 a oo:Module; oo:hasComponents n3:Parser, n3:Lexer.
n3:Parser a oo:Class oo:hasParameter
    n3:format, n3:blankNodePrefix, n3:lexer, n3:explicitQuantifiers.
n3:Lexer  a oo:Class oo:hasParameter
    n3:lineMode, n3:n3, n3:comments;

n3:format              a oo:Parameter; rdfs:range xsd:string.
n3:blankNodePrefix     a oo:Parameter; rdfs:range xsd:string.
n3:lexer               a oo:Parameter; rdfs:range n3:Lexer.
n3:explicitQuantifiers a oo:Parameter; rdfs:range xsd:boolean.
n3:lineMode            a oo:Parameter; rdfs:range xsd:boolean.
n3:n3                  a oo:Parameter; rdfs:range xsd:boolean.
n3:comments            a oo:Parameter; rdfs:range xsd:boolean.</code></pre>
<figcaption>
        <p><span class="label">Listing 2:</span> The N3.js module contains a parser, lexer and util component.
The parser and lexer are a constructable components.
The parser has a parameter that takes another component, a lexer, as input.
The util component already is an instance, for which it needs no parameters.</p>
      </figcaption>
</figure>

    <figure id="config-n3" class="listing">
<pre><code>ex:myLexer a n3:Lexer;
    n3:comments &quot;true&quot;^^xsd:boolean.

ex:myParser a n3:Parser;
    n3:format &quot;application/trig&quot;;
    n3:lexer ex:myLexer.</code></pre>
<figcaption>
        <p><span class="label">Listing 3:</span> <code>ex:myLexer</code> is a lexer that accepts comments.
<code>ex:myParser</code> is a parser that accepts the TriG format and uses <code>ex:myLexer</code> for lexing.</p>
      </figcaption>
</figure>

    <p class="todo">mention reasoning for checking things like valid parameter range</p>

    <h3 id="object-mapping">Object mapping</h3>

    <p>A consequence of using RDF to instantiate components is that the parameters have no fixed order.
While this is sufficient to describe component instantiations on a semantic level,
it is insufficient for mapping parameter values to arguments in method and constructor calls that are based on a fixed ordering for parameters,
which is the case for most popular OOP languages.</p>

    <p>We introduce a new ontology for describing the mapping between the pure semantic parameters
to arguments in method calls in OOP languages like JavaScript, hence the name <a href="http://linkedsoftwaredependencies.org/vocabularies/object-mapping">_Object Mapping ontology</a>.
<a href="#voc-om-diagram">Fig. 3</a> shows an overview of all the classes and predicates in the ontology.</p>

    <figure id="voc-om-diagram">
<img src="voc-om-diagram.svg" alt="[Object Mapping ontology diagram]" />
<figcaption>
        <p><span class="label">Fig. 3:</span> Overview of the classes and properties in the <em>Object Mapping</em> ontology.</p>
      </figcaption>
</figure>

    <p>The ontology introduces the <em>object map</em> and the <em>array map</em>, the latter is a subclass of the former.
An object map can have several <em>object map entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array map entries</em>, each entry only has a value.</p>

    <p class="todo">Consider dropping all listings in this section, we’ll need to keep the explanation conceptual there. People will need to understand <em>why</em> mappings are needed, understand high-level <em>what</em> they do, but the <em>how</em> might not be possible to explain.</p>

    <p>If the value of <code>om:fieldName</code> or <code>om:fieldValue</code> is a literal, the literal value will be mapped to the object field name or value.
An <code>om:fieldValue</code> can also refer to another object map, which will be mapped to the resulting object.
<code>om:collectsEntriesFrom</code> can refer to a predicate that points to entities with certain predicates.
Each entity predicate that is refered to by <code>om:fieldName</code> will have its values mapped to keys of the object.
Each entity predicate refered to by <code>om:fieldValue</code> will have its values mapped to values.
<a href="#om-collects-module">Listing 4</a>, <a href="#om-collects-data">Listing 5</a> and <a href="#om-collects-result">Listing 6</a> show an example of this entry collection process.</p>
    <figure id="om-collects-module" class="listing">
<pre><code>:myOm om:hasField [
    om:fieldName foaf:name;
    om:fieldValue: foaf:mbox.
    om:collectsEntriesFrom foaf:knows.
].</code></pre>
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 4:</span> An object mapping for mapping all <code>foaf:knows</code> resources to an object
with as key the <code>foaf:name</code> and as value the <code>foaf:mbox</code>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-data" class="listing">
<pre><code>:me foaf:knows :alice, :bob.
:alice foaf:name &quot;Alice&quot;;
    foaf:mbox &quot;alice@gmail.com&quot;.
:bob foaf:name &quot;Bob&quot;;
    foaf:mbox &quot;bob@ugent.be&quot;.</code></pre>
<figcaption>
        <p><span class="label">Listing 5:</span> All the people <code>:me</code> knows using the <a href="http://xmlns.com/foaf/spec/">FOAF vocabulary</a>.</p>
      </figcaption>
</figure>
    <figure id="om-collects-result" class="listing">
<pre><code>{ &quot;alice&quot;: &quot;alice@gmail.com&quot;,
  &quot;bob&quot;: &quot;bob@ugent.be&quot; }</code></pre>
<figcaption>
        <p><span class="label">Listing 6:</span> The resulting object when mapping the people <code>:me</code> knows from <a href="#om-collects-data">Listing 5</a>
using the object mapping from <a href="#om-collects-module">Listing 4</a>.</p>
      </figcaption>
</figure>

    <p><a href="#module-n3-mapped">Listing 7</a> shows the mapping of the N3.js component parameters to the constructor implementations.
This description enchances the component definitions from <a href="#module-n3">Listing 2</a>
as it provides a lower level (implementation) view on the component constructors.</p>

    <figure id="module-n3-mapped" class="listing">
<pre><code>n3:Parser oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;format&quot;;
        om:fieldValue: n3:format.
    ],
    [
        om:fieldName &quot;blankNodePrefix&quot;;
        om:fieldValue: n3:blankNodePrefix.
    ],
    [
        om:fieldName &quot;lexer&quot;;
        om:fieldValue: n3:lexer.
    ],
    [
        om:fieldName &quot;explicitQuantifiers&quot;;
        om:fieldValue: n3:explicitQuantifiers.
    ].
]).

n3:Lexer oo:constructorMapping ([
    om:hasField [
        om:fieldName &quot;lineMode&quot;;
        om:fieldValue: n3:lineMode.
    ],
    [
        om:fieldName &quot;n3&quot;;
        om:fieldValue: n3:n3.
    ],
    [
        om:fieldName &quot;comments&quot;;
        om:fieldValue: n3:comments.
    ].
]).</code></pre>
<figcaption>
        <p><span class="label">Listing 7:</span> Both the parameters of the parser and lexer component are respectively mapped to an object.
These objects are the single arguments of respectively the parser and lexer constructor.
The field value in this case is always a parameter.</p>
      </figcaption>
</figure>

  </section>

  <section id="instantiating">
    <h2>Instantiating component configurations</h2>

    <p class="todo">mention closing of the world</p>

    <p>In the previous section, we introduced a vocabulary for describing software components and how they can be instantiated.
In this section, we introduce a dependency injection framework based on these component descriptions.
With this, we take semantic software component descriptions to the next level,
we don’t only <em>describe</em> components, but also allow them to be <em>instantiated</em>.</p>

    <p>We have implemented, <a href="https://github.com/LinkedSoftwareDependencies/Components.js">Components.js</a>,
an open-source dependency injection framework for JavaScript, and made it available on <a href="https://www.npmjs.com/package/lsd-components">npm</a>.
It is able to construct component instances based on declarative component constructions in RDF using the vocabulary introduced in <a href="#describing-components">Section 5</a>.
It accepts raw triple streams or URL’s to RDF documents containing these declarations.
At the time of writing, the parser accepts RDF documents serialized in either JSON-LD, Turtle, TriG, N-Triples or N-Quads.</p>

    <p><a href="#components.js">Listing 8</a> illustrates how components can be instantiated using Components.js.
It provides a <code>Loader</code> class that acts as an assembler when instantiated.
This <code>Loader</code> provides <em>constructor injection</em>:
it dynamically calls the constructor of the component and passes the configured parameters in a single object argument.
If a constructor mapping is detected, the parameter values will be mapped to constructor arguments as configured by the mapping.
Additionally, <a href="https://github.com/LinkedSoftwareDependencies/Components.js#component-configuration-unnamed">simplified mechanisms</a>
are in place for developers that want to use the dependency injector directly without having to semantically describe the component.</p>

    <figure id="components.js" class="listing">
<pre><code>const loader = new require(&#39;lsd-components&#39;).Loader();
loader.registerModuleResourcesUrl(&#39;http://example.org/module-n3.ttl&#39;)
loader.registerConfigUrl(&#39;http://example.org/config-n3.ttl&#39;)
var myParser = loader.instantiate(&#39;http://example.org/config-n3.ttl#myParser&#39;);</code></pre>
<figcaption>
        <p><span class="label">Listing 8:</span> First, a new component loader is created
after which module and component definitions are registered.
Finally, a declarative component instantiation is supplied by providing the component URI
and the location at which the resource can be found.</p>
      </figcaption>
</figure>

  </section>

  <section id="use-case">
    <h2>Use case: describing a Linked Data Fragments experiment</h2>

    <p>In this section, we will provide a semantic description
of the experiment performed in <a property="http://purl.org/spar/cito/citesAsAuthority" href="http://linkeddatafragments.org/publications/iswc2014.pdf">a previous ISWC2014 article</a> <a class="reference" href="#ref-11">[11]</a>,
which involves specific software configurations
of a Linked Data Fragments (LDF) client and server.
This description serves as a guiding example
on how to create such descriptions for other evaluations.
The intention is that future research articles
directly describe their experimental setup this way,
either through HTML with embedded RDFa
or as a reference to an IRI of an RDF document.</p>

    <p>For this use case,
we have semantically described the <a href="https://github.com/LinkedDataFragments/Server.js/tree/feature-lsd">LDF server</a> module and its 32 components.
Instead of the former domain-specific <a href="https://github.com/LinkedDataFragments/Server.js/blob/master/config/config-example.json">JSON configuration file</a>,
the <a href="https://github.com/LinkedDataFragments/Server.js/blob/feature-lsd/config/config-example.json">semantic configuration</a> is Linked Data
and can be instantiated automatically by Components.js.</p>

    <p>The ISWC2014 LDF experiment can be described by the following steps:</p>

    <ol>
      <li>Create 1 virtual machine for the server.</li>
      <li>Create 1 virtual machine for a cache.</li>
      <li>Create 60 virtual machines for clients.</li>
      <li>Copy generated <a href="#">BSBM dataset</a> to the server.</li>
      <li>Install <a href="#">The server software configuration</a>,
implementing the <a href="https://www.hydra-cg.com/spec/latest/triple-pattern-fragments/">TPF specification</a>,
with its <a href="#">dependencies</a> on the server.</li>
      <li>Install <a href="#">The client software configuration</a>,
implementing the <a href="https://www.w3.org/TR/sparql11-protocol/">SPARQL 1.1 protocol</a>,
with its <a href="#">dependencies</a> on each client.</li>
      <li>Execute four processes of the <a href="#">BSBM benchmark</a>
with the client software for each client machine</li>
      <li>Record CPU time, RAM usage of each client,
the CPU time and RAM usage of the server,
and measure the ingoing and outgoing bandwidth of the cache.</li>
      <li>Publish <a href="http://data.linkeddatafragments.org/benchmark">results</a> results online.</li>
    </ol>

    <p class="todo">Sarven and Ruben V.:
The above description should become fully semantified.
We can do this in the article itself in HTML+RDFa
and/or as a separate Turtle file.
(Perhaps the Turtle file can be autogenerated.)</p>

    <p>Note how in the description of the experiment above,
we refer to the exact software configurations by their IRI,
their specific dependency versions,
and the specifications they implement.
Based on these IRIs,
other researchers can immediately instantiate the same configuration,
or derive their own similar configurations
to create comparative experiments.
While software container solutions, such as <a href="https://www.docker.com/">Docker</a>,
could also provide immediate instantiation,
their configuration is on a much higher level.
Instead, the Object-Oriented Components ontology
captures the low-level wiring between components,
enabling researchers to swap individual algorithms
or component settings.</p>

    <p>For example, based on the above description,
the exact same experiment can be performed
with <a property="http://purl.org/spar/cito/obtainsBackgroundFrom" href="http://linkeddatafragments.org/publications/eswc2015.pdf">different client-side algorithms</a> <a class="reference" href="#ref-12">[12]</a>
or <a property="http://purl.org/spar/cito/obtainsBackgroundFrom" href="https://arxiv.org/pdf/1608.08148.pdf">different server-side interfaces</a> <a class="reference" href="#ref-13">[13]</a>.
A common practice to achieve this currently,
as done in the aforementioned works <a class="reference" href="#ref-12">[12]</a><a class="reference" href="#ref-13">[13]</a>,
is to implement modifications in separate code repository branches.
Unfortunately,
such branches typically diverge from the main code tree,
and hence cannot be easily evaluated afterwards
with later versions of other components.
By implementing them as independent modules instead,
they can be plugged in automatically
by minimally altering the declarative experiment description.</p>

  </section>

  <section id="conclusion">
    <h2>Conclusion</h2>

    <p class="todo">Mention autogeneration of component files in future work</p>

    <p class="todo">Mention something about building sustainable research platforms.
For example, the Linked Data Fragments client and server
can be compatible with multiple APIs, have multiple algorithms, etc.
The old work is divided in different branches.
With the new work: just an URL of a configuration!
Furthermore, components can be in different modules all over the Web,
the injection framework will build everything together.</p>

    <p class="todo">Something about standing on the shoulders of giants,
about how we can reuse each other’s software more easily.</p>

  </section>

</main>

<footer>
<section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd>Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd>Berners-Lee, T.: Linked Data, <a href="https://www.w3.org/DesignIssues/LinkedData.html,">https://www.w3.org/DesignIssues/LinkedData.html,</a> (2009).</dd>
  <dt id="ref-3">[3]</dt>
  <dd>Berners-Lee, T.: Information Management: A Proposal, <a href="https://www.w3.org/History/1989/proposal.html,">https://www.w3.org/History/1989/proposal.html,</a> (1989).</dd>
  <dt id="ref-4">[4]</dt>
  <dd>Rietveld, L., Beek, W., Schlobach, S.: LOD Lab: Experiments at LOD Scale. In: Arenas, M., Corcho, O., Simperl, E., Strohmaier, M., d’Aquin, M., Srinivas, K., Groth, P., Dumontier, M., Heflin, J., Thirunarayan, K., and Staab, S. (eds.) Proceedings of the 14th International Semantic Web Conference. pp. 339–355. Springer (2015).</dd>
  <dt id="ref-5">[5]</dt>
  <dd>Rautenberg, S., Ermilov, I., Marx, E., Auer, S., Ngomo, A.-C.N.: LODFlow: A Workflow Management System for Linked Data Processing. In: Proceedings of the 11th International Conference on Semantic Systems. pp. 137–144. ACM, New York, NY, USA (2015).</dd>
  <dt id="ref-6">[6]</dt>
  <dd>Mens, T., Wermelinger, M.: Separation of Concerns for Software Evolution. Journal of Software Maintenance. 14, 311–315 (2002).</dd>
  <dt id="ref-7">[7]</dt>
  <dd>Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern, <a href="https://martinfowler.com/articles/injection.html,">https://martinfowler.com/articles/injection.html,</a> (2004).</dd>
  <dt id="ref-8">[8]</dt>
  <dd>Fowler, M.: Inversion Of Control, <a href="https://martinfowler.com/bliki/InversionOfControl.html,">https://martinfowler.com/bliki/InversionOfControl.html,</a> (2005).</dd>
  <dt id="ref-9">[9]</dt>
  <dd>Johnson, R.E., Foote, B.: Designing reusable classes. Journal of object-oriented programming. 1, 22–35 (1988).</dd>
  <dt id="ref-10">[10]</dt>
  <dd>Sweet, R.E.: The Mesa programming environment. In: ACM SIGPLAN Notices. pp. 216–229. ACM (1985).</dd>
  <dt id="ref-11">[11]</dt>
  <dd>Verborgh, R., Hartig, O., De Meester, B., Haesendonck, G., De Vocht, L., Vander Sande, M., Cyganiak, R., Colpaert, P., Mannens, E., Walle, R. Van de: Querying Datasets on the Web with High Availability. In: Mika, P., Tudorache, T., Bernstein, A., Welty, C., Knoblock, C., Vrandečić, D., Groth, P., Noy, N., Janowicz, K., and Goble, C. (eds.) Proceedings of the 13th International Semantic Web Conference. pp. 180–196. Springer (2014).</dd>
  <dt id="ref-12">[12]</dt>
  <dd>Van Herwegen, J., Verborgh, R., Mannens, E., Walle, R. Van de: Query Execution Optimization for Clients of Triple Pattern Fragments. In: Gandon, F., Sabou, M., Sack, H., d’Amato, C., Cudré-Mauroux, P., and Zimmermann, A. (eds.) The Semantic Web. Latest Advances and New Domains. pp. 302–318 (2015).</dd>
  <dt id="ref-13">[13]</dt>
  <dd>Hartig, O., Buil-Aranda, C.: Bindings-Restricted Triple Pattern Fragments. In: Debruyne, C., Panetto, H., Meersman, R., Dillon, T., Kühn, eva, O’Sullivan, D., and Ardagna, C.A. (eds.) Proceedings of the 15th International Conference on Ontologies, DataBases, and Applications of Semantics. pp. 762–779. Springer (2016).</dd>
</dl>
</section>
</footer>



</body>
</html>
