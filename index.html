<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Reproduceable software experiments through semantic configurations</title>
  <link rel="stylesheet" media="screen" href="styles/screen.css">
  <link rel="stylesheet" media="print"  href="styles/print.css">
</head>
<body>
  <header>
  <h1 id="reproduceable-software-experiments-through-semanticconfigurations">Reproduceable software experiments through semantic configurations</h1>

  <ul id="authors">
    <li><a href="http://www.rubensworks.net/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://www.rubensworks.net/#me">Ruben Taelman</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://joachim-loves-hamburgersss.linkedsoftwaredependencies.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://data.verborgh.org/people/joachim_van_herwegen">Joachim Van Herwegen</a>
<a href="#idlab"><sup>1</sup></a></li>
    <li><a href="http://csarven.ca/" typeof="http://xmlns.com/foaf/0.1/Person" resource="http://csarven.ca/#i">Sarven Capadisli</a>
<a href="#eisd"><sup>2</sup></a></li>
    <li><a href="https://ruben.verborgh.org/" typeof="http://xmlns.com/foaf/0.1/Person" resource="https://ruben.verborgh.org/profile/#me">Ruben Verborgh</a>
<a href="#idlab"><sup>1</sup></a></li>
  </ul>

  <ul id="affiliations">
    <li id="idlab"><sup>1</sup>IDLab,
          Department of Electronics and Information Systems,
          Ghent University – imec</li>
    <li id="eisd"><sup>2</sup>Enterprise Information Systems Department,
          University of Bonn</li>
  </ul>

  <section id="abstract">
    <h2>Abstract</h2>
    <!-- Context      -->
    <p>The scientific process requires reproducible experiments and findings
to foster trust and accountability.
Within computer science engineering,
reproducing experiments involves setting up
the exact same software with the same benchmarks and test data,
which often requires non-trivial manual work.
<!-- Need         -->
Unfortunately,
many research articles ambiguously refer to software by name only,
leaving out crucial details such as module and dependency version numbers
or the configuration of the individual components.
<!-- Task         -->
To this end, we created vocabularies
for the semantic description of software components and their configuration,
which can be published as Linked Data alongside experimental results.
We implemented a dependency injection framework
to accurately instantiate these described experimental configurations.
<!-- Object       -->
This article discusses the approach and its application,
and explains with a use case
how to publish experiments and their software configurations on the Web.
<!-- Findings     -->
In order to enable semantic interlinking between configurations and modules,
we published the metadata of all 475,000+ JavaScript libraries on npm
as 150,000,000+ RDF triples.
<!-- Conclusion   -->
Through our work,
research articles can refer by URL
to fine-grained, instantiatable descriptions of experimental setups,
completing the provenance chain from
specifications to implementations, dependencies, and configurations
all the way to experimental results.
This ultimately brings faster and more accurate reproductions of experiments,
and facilitates the evaluation of new research contributions.
<!-- Perspectives -->
Moreover, this work can serve other use cases,
such as general software instantiation outside of experiments,
and query execution over software configuration metadata.</p>

  </section>

</header>

<main>
  <section id="introduction">
    <h2>Introduction</h2>

    <p>Too many computer science articles
that contain experimental software evaluations
identify that software only by name and, sometimes, version number.
This information is insufficient for readers
to understand which <em>exact</em> version of the software,
which exact versions of its <em>dependencies</em>,
and which detailed <em>configuration</em> of the software’s components
has in fact obtained the reported results.
Therefore, potential users cannot necessarily obtain the correct software installation
that will behave according to the article’s conclusions.
Moreover, other researchers might fail
in reproducing the same results
because of differences in any of these aspects.</p>

    <p>As <a property="http://purl.org/spar/cito/providesQuotationFor" href="http://www-stat.stanford.edu/~donoho/Reports/1995/wavelab.pdf">Claerbout’s Principle</a> <a class="reference" href="#ref-1">[1]</a> explains,
<q>an article about computational science in a scientific publication
is not the scholarship itself, it is merely <strong>advertising</strong> of the scholarship.
The actual scholarship is the complete software development environment
and the complete set of instructions which generated the figures.</q>
This stresses the importance of reproducibility,
and essentially mandates a detailed description
of the executed experiment, the involved artefacts and actors,
and the processing of the retrieved data.</p>

    <p>Using Linked Data to publish such descriptions provides two immediate benefits:
the experimental setup and parts thereof can be <em>identified with IRIs</em>,
and their details can be retrieved by <em>dereferencing those IRIs</em>.
Therefore, if research articles complement their textual explanation of an experiment
with the IRI of the full setup, reproducibility is guaranteed</p>

    <p class="todo">“Guaranteed” may be too strong?</p>
    <p>Moreover, the IRIs of the entire experiment or its parts
can be reused in other articles or experiment
to unambiguously refer to the same conditions.
<a href="#description-diagram">Fig. 1</a> illustrates how this leads to a chain of provenance
from the research article to the data
and the experiment that generates it,
and all the aspects surrounding that experiment.</p>

    <figure id="description-diagram">
<img src="description-diagram.svg" alt="[description diagram]" />
<figcaption>
        <p><span class="label">Fig. 1:</span> A <em>research article</em> is based on <em>result data</em>,
which are the outcomes of an <em>experiment</em>.
The experiment in turn also has (multiple) provenance chains,
and this article focuses on <em>software configurations</em> and <em>software modules</em>.</p>
      </figcaption>
</figure>

    <p>In this article,
we focus on the description of <em>software configurations</em> and <em>software modules</em>,
such that an evaluated software setup
can be referred to unambiguously by an IRI.
We thereby avoid the inherent vagueness
of referring to software by name only.
We further facilitate the reproduction of experiments
through a mechanisms that automatically <em>instantiates</em> the software configuration
based on its Linked Data description.
Our contributions are the following:</p>

    <ul>
      <li>the RDF-based description of <strong>software modules</strong>,
applied to the 475,000+ bundles of the npm ecosystem for Node.js;</li>
      <li>the RDF-based description of <strong>available components</strong> within software modules;</li>
      <li>the RDF-based description of a <strong>precise configuration</strong> of software modules;</li>
      <li>the <strong>automated instantiation</strong> of such a configuration;</li>
      <li>a <strong>use case</strong> explaining the usage of the resulting Linked Data
in scientific articles.</li>
    </ul>

    <p class="todo">Would a figure explaining the relation between module, component, configuration and instance be useful here?</p>

    <p>Add outline: <a href="#related-work">Section 2</a>, <a href="#overview">Section 3</a>, …</p>

  </section>

  <section id="related-work">
    <h2>Related Work</h2>

    <p class="todo">Introduce section structure</p>

    <h3 id="scholarly-publishing-and-reproducibility">Scholarly publishing and reproducibility</h3>
    <p class="todo">Sarven will start this</p>

    <p class="todo">We should cite <a property="http://purl.org/spar/cito/cites" href="http://laurensrietveld.nl/pdf/lodlab.pdf">LOD Lab</a> <a class="reference" href="#ref-2">[2]</a>,
as they brought a major new angle to reproducibility within the Semantic Web.
Should also look at their argumentation.</p>

    <h3 id="ontologies-and-vocabularies-for-describing-experiments">Ontologies and vocabularies for describing experiments</h3>
    <p class="todo">Sarven will start this</p>

    <h3 id="related-work-dependency-injection">Dependency injection</h3>

    <p>Software frameworks are often based on the concept of <a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/bliki/InversionOfControl.html">Inversion of Control</a> <a class="reference" href="#ref-3">[3]</a><a class="reference" href="#ref-4">[4]</a>.
Inversion of Control is, according to <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/bliki/InversionOfControl.html">Fowler</a> <a class="reference" href="#ref-3">[3]</a>, <q>a key part of what makes a framework different to a library</q>.
While a library provides functions that can be called by you, a framework provides some form kind of workflow,
where you can plug in certain functionality, and the framework will call you when needed<sup id="fnref:HollywoodPrinciple"><a href="#fn:HollywoodPrinciple" class="footnote">1</a></sup>.</p>

    <p><a property="http://purl.org/spar/cito/cites" href="https://martinfowler.com/articles/injection.html">Dependency Injection</a> <a class="reference" href="#ref-6">[6]</a> is a form of Inversion of Control where components
are injected into other components by an external component.
Fowler defines a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-6">[6]</a> as
<q>a glob of software that’s intended to be used, without change, by an application that is out of the control of the writers of the component</q>.
Three types of dependency injection are typically distinguished,
which always need an external <em>Assembler</em> component that is responsible for injecting the components.</p>

    <ul>
      <li>Interface injection: The assembler calls an <code>inject</code> method in the target component to inject its dependencies.</li>
      <li>Setter injection: The assembler maps interfaces to implementation instances.</li>
      <li>Constructor injection: The assember maps interfaces to implementation classes with their constructor parameters and allows dynamic construction.</li>
    </ul>

    <p>Each of these types requires a configuration phase to wire the component instances or factories,
and an injection phase to plug in the actual dependencies inside components.
This wiring can either be done in code, or through external configuration files.
These configuration files are typically declarative, and can be defined in formats such as XML or JSON.
Separating configuration from code is considered a good practise in software design,
as it follows the principle of separating interfaces from implementation.</p>

  </section>

  <section id="overview">
    <h2>Overview of software experiment descriptions</h2>

    <p class="todo">This section will shortly introduce each of the blocks in the diagram.
Ruben V. will write the basis.</p>

    <p class="todo">Mention somewhere here that we will use JSON-LD syntax for the examples in this paper.</p>

    <h4 id="specification">Specification</h4>
    <p class="todo">Write</p>

    <h4 id="module">Module</h4>
    <p class="todo">Write</p>

    <p class="todo">A module consists of <em>components</em></p>

    <h4 id="configuration">Configuration</h4>
    <p class="todo">Write</p>

    <h4 id="experiment">Experiment</h4>
    <p class="todo">Write</p>

    <h4 id="results">Results</h4>
    <p class="todo">Write</p>

    <h4 id="article">Article</h4>
    <p class="todo">Write</p>

  </section>

  <section id="describing-modules">
    <h2>Describing software modules</h2>

    <p class="todo">Joachim writes this</p>

  </section>

  <section id="describing-components">
    <h2>Describing components and their configuration</h2>

    <p class="todo">Ruben T. writes this</p>

    <p>In this section, we introduce a vocabulary for describing software components and how they can be instantiated.
We provide an example of the application of this vocabulary to object-oriented software components using JavaScript.</p>

    <h3 id="components">Components</h3>

    <p>Within the components vocabulary, we reuse Fowler’s definition of a <a property="http://purl.org/spar/cito/providesQuotationFor" href="https://martinfowler.com/articles/injection.html">software component</a> <a class="reference" href="#ref-6">[6]</a>.
The purpose of a component is to provide operations that can be used by other components.
The instantiation of a component can require certain parameters,
just like object-oriented programming (OOP) languages allow constructors to have certain arguments.</p>

    <p class="todo">link to voc</p>

    <p>We define a <em>module</em> as a collection of components.
Within OOP languages, this can correspond to for example a software library or an application,
which can contain a multitude of functionalities, i.e., components.</p>

    <p>We define a component as a <em>subtype</em> of <code>rdfs:Class</code>.
The parameters to construct a component can therefore be defined as an <code>rdfs:Property</code> on a component.
This simple component structure enables convenient semantic descriptions of components instantiations,
requiring only the fundamental concepts of RDF classes and properties.</p>

    <p>Figure TODO shows an overview of all the classes and predicates in the components vocabulary.</p>

    <p class="todo">figure</p>

    <p>Several component subtypes are defined.
A component can be constructable, which means that it requires some form of instantiation before it can be used elsewhere.
It can also be a direct instance, meaning that it can directly be used within other components and needs no further instantiation.
A component can also be abstract, which does not allow directly instantiating this component type.
Abstract components can be used to define a set of shared parameters in a common ancestor.
Conforming to the RDF semantics, components can have multiple ancestors, and are indicating using the <code>rdfs:subClassOf</code> predicate.</p>

    <p class="todo">Say some things about parameters once the vocabulary on this has been fixed.</p>

    <p><a href="#module-n3">Listing 1</a> shows an example of the N3.js npm module using the components vocabulary.
It exposes several components such as <em>Parser</em> and <em>Lexer</em>.
Each of these components can take several different parameters.
<a href="#config-n3">Listing 2</a> illustrates how instances can be created of these component types.</p>

    <figure id="module-n3" class="listing">
<pre><code>ex:n3 a lsdc:Module;
    lsdc:hasComponents
        n3:Parser,
        n3:Lexer.

n3:Parser a lsdc:ComponentConstructable
    lsdc:hasParameter n3:format,
        n3:blankNodePrefix,
        n3:lexer,
        n3:explicitQuantifiers.

n3:format a lsdc:Parameter;
    rdfs:range xsd:string.
n3:blankNodePrefix a lsdc:Parameter;
    rdfs:range xsd:string.
n3:lexer a lsdc:Parameter;
    rdfs:range n3:Lexer.
n3:explicitQuantifiers a lsdc:Parameter;
    rdfs:range xsd:boolean.

n3:Lexer a lsdc:ComponentConstructable
    lsdc:hasParameter n3:lineMode,
        n3:n3,
        n3:comments;

n3:lineMode a lsdc:Parameter;
    rdfs:range xsd:boolean.
n3:n3 a lsdc:Parameter;
    rdfs:range xsd:boolean.
n3:comments a lsdc:Parameter;
    rdfs:range xsd:boolean.</code></pre>
<figcaption>
        <p><span class="label">Listing 1:</span> The N3.js module contains a parser, lexer and util component.
The parser and lexer are a constructable components.
The parser has a parameter that takes another component, a lexer, as input.
The util component already is an instance, for which it needs no parameters.</p>
      </figcaption>
</figure>

    <figure id="config-n3" class="listing">
<pre><code>ex:myLexer a n3:Lexer;
    n3:comments &quot;true&quot;^^xsd:boolean.

ex:myParser a n3:Parser;
    n3:format &quot;application/trig&quot;;
    n3:lexer ex:myLexer.</code></pre>
<figcaption>
        <p><span class="label">Listing 2:</span> <code>ex:myLexer</code> is a lexer that accepts comments.
<code>ex:myParser</code> is a parser that accepts the TriG format and uses <code>ex:myLexer</code> for lexing.</p>
      </figcaption>
</figure>

    <p>{:.todo} mention reasoning for checking things like valid parameter range</p>

    <h3 id="object-oriented-components">Object-oriented components</h3>

    <p>A consequence of using RDF to instantiate components is that the parameters have no fixed order.
While this is sufficient to describe component instantiations on a semantic level,
it is insufficient for mapping parameter values to arguments in method and constructor calls that are based on a fixed ordering for parameters,
which is the case for most popular programming languages.</p>

    <p>We introduce a new vocabulary for describing the mapping between the pure semantic parameters
to arguments in method calls in OOP languages like JavaScript, hence the name <em>object mapping vocabulary</em>.</p>

    <p class="todo">link to voc</p>

    <p>Our vocabulary introduces the <em>object map</em> and the <em>array map</em>, the latter is a subclass of the former.
An object map can have several <em>object map entries</em>, where each entry has a field name and a field value.
An array map can have several <em>array map entries</em>, each entry only has a value.</p>

    <p>Figure TODO shows an overview of all the classes and predicates in the components vocabulary.</p>

    <p>If the value of <code>fieldName</code> or <code>fieldValue</code> is a literal, the literal value will be mapped to the object field name or value.
A <code>fieldValue</code> can also refer to another object map, which will be mapped to the resulting object.
An object map can be dynamic, where the object field names and values can be mapped dynamically based on predicates.</p>

    <p><a href="#module-n3-mapped">Listing 3</a> shows the mapping of the N3.js component parameters to the constructor implementations.
This description enchances the component definitions from <a href="#module-n3">Listing 1</a>
as it provides a lower level (implementation) view on the component constructors.</p>

    <figure id="module-n3-mapped" class="listing">
<pre><code>n3:Parser lsdc:constructorMapping ([
    om:hasField [
        om:fieldName &quot;format&quot;;
        om:fieldValue: n3:format.
    ],
    [
        om:fieldName &quot;blankNodePrefix&quot;;
        om:fieldValue: n3:blankNodePrefix.
    ],
    [
        om:fieldName &quot;lexer&quot;;
        om:fieldValue: n3:lexer.
    ],
    [
        om:fieldName &quot;explicitQuantifiers&quot;;
        om:fieldValue: n3:explicitQuantifiers.
    ].
]).

n3:Lexer lsdc:constructorMapping ([
    om:hasField [
        om:fieldName &quot;lineMode&quot;;
        om:fieldValue: n3:lineMode.
    ],
    [
        om:fieldName &quot;n3&quot;;
        om:fieldValue: n3:n3.
    ],
    [
        om:fieldName &quot;comments&quot;;
        om:fieldValue: n3:comments.
    ].
]).</code></pre>
<figcaption>
        <p><span class="label">Listing 3:</span> Both the parameters of the parser and lexer component are respectively mapped to an object.
These objects are the single arguments of respectively the parser and lexer constructor.
The field value in this case is always a parameter.</p>
      </figcaption>
</figure>

  </section>

  <section id="instantiating">
    <h2>Instantiating component configurations</h2>

    <p>In the previous section, we introduced a vocabulary for describing software components and how they can be instantiated.
In this section, we introduce a dependency injection framework based on these component descriptions.
With this, we take semantic software component descriptions to the next level,
we don’t only <em>describe</em> components, but also allow them to be <em>instantiated</em>.</p>

    <p>We have implemented, <a href="https://github.com/LinkedSoftwareDependencies/Components.js">Components.js</a>,
an open-source dependency injection framework for JavaScript, and made it available on <a href="https://www.npmjs.com/package/lsd-components">npm</a>.
It is able to construct component instances based on declarative component constructions in RDF using the vocabulary introduced in <a href="#describing-components">Section 5</a>.
It accepts raw triple streams or URL’s to RDF documents containing these declarations.
At the time of writing, the parser accepts RDF documents serialized in either JSON-LD, Turtle, TriG, N-Triples or N-Quads.</p>

    <p><a href="#components.js">Listing 4</a> illustrates how components can be instantiated using Components.js.
It provides a <code>Loader</code> class that acts as an assembler when instantiated.
This <code>Loader</code> is based on the principles of <em>Constructor injection</em>, as explained in <a href="#related-work-dependency-injection">Subsection 2.3</a>
It dynamically calls the constructor of the component and passes the configured parameters in a single object argument.
If a constructor mapping is detected, the parameter values will be mapped to constructor arguments as configured by the mapping.
Additionally, <a href="https://github.com/LinkedSoftwareDependencies/Components.js#component-configuration-unnamed">simplified mechanisms</a>
are in place for developers that want to use the dependency injector directly without having to semantically describe the component.</p>

    <figure id="components.js" class="listing">
<pre><code>const Loader = require(&#39;lsd-components&#39;).Loader;
let loader = new Loader();
loader.registerModuleResourcesUrl(
    &#39;http://example.org/module-n3.ttl&#39;)
    .then(() =&gt;loader.instantiateFromUrl(
        &#39;http://example.org/config-n3.ttl#myParser&#39;,
        &#39;http://example.org/config-n3.ttl&#39;))
    .then((parser) =&gt; { ... });</code></pre>
<figcaption>
        <p><span class="label">Listing 4:</span> First, a new component loader is created
after which module and component definitions are registered.
Finally, a declarative component instantiation is supplied by providing the component URI
and the location at which the resource can be found.</p>
      </figcaption>
</figure>

  </section>

  <section id="use-case">
    <h2>Use case: a Linked Data Fragments experiment</h2>

    <p class="todo">Sarven, Joachim, Ruben V. write this</p>

    <p><a property="http://purl.org/spar/cito/citesAsAuthority" href="http://linkeddatafragments.org/publications/jws2016.pdf">Linked Data Fragments</a> <a class="reference" href="#ref-7">[7]</a></p>

    <p>We have implemented a new version of the <a href="https://github.com/LinkedDataFragments/Server.js/tree/feature-lsd">LDF server</a>
where all components are dynamically wired by Components.js.
We semantically describe the LDF server module and its 32 components, which results in x triples.
The configuration file used to be a <a href="https://github.com/LinkedDataFragments/Server.js/blob/master/config/config-example.json">JSON file</a>
with a custom domain-specific language.
Now, this configuration file is a declarative components file that can be understood by Components.js,
as can be seen in <a href="#ldf-server-config">Listing 5</a>.
This new configuration format has two major advantages:</p>

    <ul>
      <li>The configuration file is RDF data with a semantic meaning.</li>
      <li>External components can be injected by including declaratively into the config file.</li>
    </ul>

    <figure id="ldf-server-config" class="listing">
<pre><code>{
  &quot;@context&quot;: {
    &quot;rdfs&quot;: &quot;http://www.w3.org/2000/01/rdf-schema#&quot;,
    &quot;npmd&quot;: &quot;http://linkedsoftwaredependencies.org/bundles/npm/&quot;,
    &quot;ldfs&quot;: &quot;npmd:ldf-server/&quot;,
    &quot;rdfa&quot;: &quot;http://www.w3.org/ns/rdfa#&quot;
  },
  &quot;@id&quot;: &quot;urn:ldfserver:my&quot;,
  &quot;@type&quot;: &quot;ldfs:Server/Qpf&quot;,

  &quot;rdfs:label&quot;: &quot;My Linked Data Fragments server&quot;,

  &quot;ldfs:datasource&quot;: [
    {
      &quot;@id&quot;: &quot;ex:myHdtDatasource&quot;,
      &quot;@type&quot;: &quot;ldfs:Datasource/Hdt&quot;,
      &quot;rdfs:label&quot;: &quot;DBpedia 2014&quot;,
      &quot;rdfs:comment&quot;: &quot;DBpedia 2014 with an HDT back-end&quot;,
      &quot;ldfs:Datasource/path&quot;: &quot;dbpedia&quot;,
      &quot;ldfs:Datasource/Hdt/file&quot;: &quot;data/dbpedia2014.hdt&quot;
    },
    {
      &quot;@id&quot;: &quot;ex:mySparqlDatasource&quot;,
      &quot;@type&quot;: &quot;ldfs:Datasource/Sparql&quot;,
      &quot;rdfs:label&quot;: &quot;DBpedia 3.9 (Virtuoso)&quot;,
      &quot;rdfs:comment&quot;: &quot;DBpedia 3.9 with a Virtuoso back-end&quot;,
      &quot;ldfs:Datasource/path&quot;: &quot;dbpedia-sparql&quot;,
      &quot;ldfs:Datasource/Sparql/endpoint&quot;: &quot;http://dbpedia.restdesc.org/&quot;,
      &quot;ldfs:Datasource/Sparql/defaultGraph&quot;: &quot;http://dbpedia.org&quot;
    }
  ]
}</code></pre>
<figcaption>
        <p><span class="label">Listing 5:</span> We define an LDF server component of type <code>ldfs:Server/Qpf</code> in JSON-LD.
The two datasources are also components that are loaded into the LDF server.</p>
      </figcaption>
</figure>

    <p>{:.todo} count triples</p>

  </section>

  <section id="conclusion">
    <h2>Conclusion</h2>

    <p class="todo">Write</p>

  </section>

</main>

<footer>
      <section id="footnotes">
        <h2>Footnotes</h2>
        <ol>
    <li id="fn:HollywoodPrinciple">
      <p>This concept is also know as the Hollywood Principle <a class="reference" href="#ref-5">[5]</a>: <q>Don’t call us, we’ll call you</q>&nbsp;<a href="#fnref:HollywoodPrinciple" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
      </section>
    <section id="references">
<h2>References</h2>
<dl class="references">
  <dt id="ref-1">[1]</dt>
  <dd>Buckheit, J.B., Donoho, D.L.: WaveLab and Reproducible Research. Stanford University (1995).</dd>
  <dt id="ref-2">[2]</dt>
  <dd>Rietveld, L., Beek, W., Schlobach, S.: LOD Lab: Experiments at LOD Scale. In: Arenas, M., Corcho, O., Simperl, E., Strohmaier, M., d’Aquin, M., Srinivas, K., Groth, P., Dumontier, M., Heflin, J., Thirunarayan, K., and Staab, S. (eds.) Proceedings of the 14th International Semantic Web Conference. pp. 339–355. Springer (2015).</dd>
  <dt id="ref-3">[3]</dt>
  <dd>Fowler, M.: InversionOfControl, <a href="https://martinfowler.com/bliki/InversionOfControl.html,">https://martinfowler.com/bliki/InversionOfControl.html,</a> (2005).</dd>
  <dt id="ref-4">[4]</dt>
  <dd>Johnson, R.E., Foote, B.: Designing reusable classes. Journal of object-oriented programming. 1, 22–35 (1988).</dd>
  <dt id="ref-5">[5]</dt>
  <dd>Sweet, R.E.: The Mesa programming environment. In: ACM SIGPLAN Notices. pp. 216–229. ACM (1985).</dd>
  <dt id="ref-6">[6]</dt>
  <dd>Fowler, M.: Inversion of Control Containers and the Dependency Injection pattern, <a href="https://martinfowler.com/articles/injection.html,">https://martinfowler.com/articles/injection.html,</a> (2004).</dd>
  <dt id="ref-7">[7]</dt>
  <dd>Verborgh, R., Vander Sande, M., Hartig, O., Van Herwegen, J., De Vocht, L., De Meester, B., Haesendonck, G., Colpaert, P.: Triple Pattern Fragments: a Low-cost Knowledge Graph Interface for the Web. Journal of Web Semantics. 37–38, 184–206 (2016).</dd>
</dl>
</section>
</footer>





</body>
</html>
